{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to CSSE4011","text":"<p>Hey everyone, Welcome to <code>CSSE4011</code>!.</p> <p>The following set of documentation are meant to help you get upto speed with Zephyr RTOS. There are 3 sections:</p> <ul> <li>OS               - OS Basics</li> <li>Connectivity     - I/O with Zephyr</li> <li>Boards           - Board setup guides</li> </ul> <p>The tutorials in each of these sections are meant to help you prepare for upcoming practicals. You should attempt/read through them to understand the basics. </p> <p>If you have any questions/issues, feel free to ask us on Ed or to come along to the pracs!    Thulith Wilfred,</p>"},{"location":"about/","title":"Tutorial Documentation","text":""},{"location":"about/#os","title":"OS","text":"<p>A set of tutorials focused on getting upto speed with Zephyr RTOS and it's feature set/implementation. <pre><code>Tute 1: Getting Started               [OK]\n    1.5: Zephyr Version Changes       [OK]\nTute 2: First program                 [OK]\n    2.1: Building Tips                [OK]\n    2.2: Implementing Libraries       [OK]\nTute 3: Debugger\nTute 4: Threading                     [OK]\nTute 5: Thread Synchronisation        \n    5.1: Thread Sync                  [OK]\n    5.2: Thread Communications (ITC)  [OK]\nTute 6: File Systems                  [N/A]\n</code></pre></p>"},{"location":"about/#connectivity","title":"Connectivity","text":"<p>A set of tutorials that expose connectivity / I/O features of Zephyr RTOS <pre><code>Tute 1: GPIO                        [OK]\nTute 2: Sensors                     [N/A]\nTute 3: Serial Console              [OK]\nTute 4: Shell                       [OK]\n    Tute 4.1: Shell Commands        [OK]\nTute 5: Logging                     [OK]\nTute 6: Segger RTT                  [OK]\n</code></pre></p>"},{"location":"about/#networking","title":"Networking","text":"<p>The following set of tutorials will focus on introducing networking within Zephyr RTOS. <pre><code>Tute 1: BLE                         [N/A]\nTute 2: Lorawan                     [N/A]\nTute 3: Web Dashboard               [N/A]\n</code></pre></p>"},{"location":"about/#boards","title":"Boards","text":"<p>A step-by-step guide to building Zephyr applications for the following boards, that are to be used within the course.  <pre><code>Tute 1: Arduino Sense             [OK]\nTute 2: Thingy52                  [OK]\nTute 3: nRF52840 Dongle           [OK]\nTute 4: Particle Argon            [OK]\n</code></pre></p>"},{"location":"about/#notes","title":"Notes","text":"<ul> <li>The following tutorials were created with reference to Zephyr RTOS V2.7.XX. </li> </ul>"},{"location":"Boards/BRD.1-Arduino_Sense/","title":"CSSE4011: Arduino-Sense: Zephyr Board Guide","text":""},{"location":"Boards/BRD.1-Arduino_Sense/#10-prerequisites","title":"1.0 Prerequisites","text":"<p>Complete following OS tutes</p> <ol> <li>Getting Started</li> <li>First Program</li> </ol>"},{"location":"Boards/BRD.1-Arduino_Sense/#20-arduino-sense-zephyr","title":"2.0 Arduino Sense - Zephyr","text":"<p>This Arduino board requires an extra step compared to building and flashing a most other boards. This particular board requires \"the Arduino variant of bossac\". Where, BOSSA - \"Basic Open Source Sam-ba Application\" and \"SAM-BA\" is the \"SAM Boot Assistant\". BOSSAC is a command-line implementation of BOSSA.</p>"},{"location":"Boards/BRD.1-Arduino_Sense/#21-getting-the-bossac","title":"2.1 Getting the BOSSAC","text":"<p>The bossac can be setup in a few different ways, the easiest is to clone the appropriate repository and compile the program. </p> <p>In the csse4011-vm, after completing the getting started guide, perform the following.</p> <p>Step 1: Install Dependencies <pre><code>sudo apt-get install libreadline-dev libwxgtk3.0-gtk3-dev\n</code></pre> Step 2: Clone BOSSA <pre><code>cd csse4011/\ngit clone https://github.com/arduino/BOSSA.git\n</code></pre> Step 3: Make Bossa <pre><code>cd BOSSA/\nmake\n</code></pre> Step 4: Verify that bin/ has been successfully created with a binary named 'bossac'. </p>"},{"location":"Boards/BRD.1-Arduino_Sense/#22-tty-permissions-for-flashing","title":"2.2 TTY Permissions for Flashing","text":"<p>To allow for west to load binary into bootloader, tty permissions must be given to the user. An easy way to do this is to add the current user to the 'dialout' group.</p> <pre><code>sudo usermod -a -G dialout $USER\n</code></pre> <p>You will typically need to log out and log in or reboot to see this effect. </p>"},{"location":"Boards/BRD.1-Arduino_Sense/#23-building-and-flashing","title":"2.3 Building and Flashing","text":"<p>Ensure that the USB is connected to the Arduino Sense board, and that it is passed through by the host machine into the virtual machine.</p> <p>An application for this board can be built with, (from within Zephyr Application directory - see OS.1)</p> <p><pre><code>west  build -p auto -b arduino_nano_33_ble\n</code></pre> and flashed with</p> <pre><code>west flash --bossac=$HOME/csse4011/BOSSA/BOSSA/bin/bossac\n</code></pre> <p>where $HOME is typically, /home/user, so ensure that the path to 'bossac' is correct.</p>"},{"location":"Boards/BRD.2-Thingy52/","title":"CSSE4011: Thingy52: Zephyr Board Guide","text":""},{"location":"Boards/BRD.2-Thingy52/#10-prerequisites","title":"1.0 Prerequisites","text":"<p>Complete following OS tutes</p> <ol> <li>Getting Started</li> <li>First Program</li> </ol>"},{"location":"Boards/BRD.2-Thingy52/#11-test-hardware","title":"1.1 Test Hardware","text":"<ul> <li>Thingy52</li> <li>2x mUSB Cable</li> <li>Segger J-Link EDU mini</li> </ul>"},{"location":"Boards/BRD.2-Thingy52/#20-install-jlinksoftwaresegger-tools","title":"2.0 Install JLinkSoftware/SEGGER Tools","text":"<p>NOTE: For flashing to work (using Segger JLink devices), you must first install J-Link Software and Documentation pack in your VM, use the <code>64-bit DEB</code> installer for Debian/Ubuntu. </p> <p>To install this, open up a terminal and navigate to download location.</p> <pre><code>cd ~/Downloads\n\n#Make sure the file name is right, versions change often\nsudo dpkg -i JLink_Linux_V762_x86_64.deb\n</code></pre> <p>Make sure that the JLink device is connected up properly to the Thingy52 device, and ensure that the power switch is to the left (facing you - on position). It is a good idea to have the device connected via mUSB for charging during this procedure.</p> <p>Once this has been completed, you can test that it is functional with</p> <pre><code>$ JLinkExe\n</code></pre> <pre><code>SEGGER J-Link Commander V7.62 (Compiled Feb 16 2022 16:09:54)\nDLL version V7.62, compiled Feb 16 2022 16:09:39\n\nConnecting to J-Link via USB...O.K.\nFirmware: J-Link EDU Mini V1 compiled Dec  7 2021 08:38:51\nHardware version: V1.00\nS/N: 801026632\nLicense(s): FlashBP, GDB\nUSB speed mode: Full speed (12 MBit/s)\nVTref=3.286V\n</code></pre> <p>at this point if you get</p> <pre><code>Connecting to J-Link via USB...FAILED: Cannot connect to J-Link.\n</code></pre> <p>This means that either your connections are wrong or more likely that the VM has not been passed the USB from host. You can test this by running.</p> <p><pre><code>lsusb\n\nBus 001 Device 003: ID 1366:0101 SEGGER J-Link PLUS\n</code></pre> If you do not see this device, check if the host can see this device, if so, you will need to configure the VM to allow passthrough for the SEGGER EDU Mini.</p>"},{"location":"Boards/BRD.2-Thingy52/#30-build-a-sample-program-blinky-for-the-argon-board","title":"3.0 Build a Sample Program (Blinky) for the Argon Board","text":"<p>If the installation was successful, we should now be able to build a basic blinky program. In the following command, the '-p auto' option automatically cleans byproducts from a previous build if necessary, which is useful if you try building another sample.</p> <p>The '-b' option specifies a board to build for, in this case the particle_argon, followed by the path to the app source. <pre><code>cd ~/csse4011/zephyrproject/zephyr/\n\nwest build -p auto -b particle_argon samples/basic/blinky\n</code></pre> Flash the sample program. Make a sure a 'runner' is connected. You will be given a Segger J-Link device to be used with the Particle Argon. <pre><code>west flash -r jlink\n</code></pre></p> <p>Option '-r' specifies to flash using JLink, west is capable of tapping into different runners for flashing your devices, later we will explore how to specify runners in the CMakeLists file. </p> <p>Additional information for setting up other runners can be found here</p>"},{"location":"Boards/BRD.2-Thingy52/#40-example-with-thingy52-zephyr","title":"4.0 Example with Thingy52 - Zephyr","text":"<p>The thingy52 has a simple build and flash procedure. To build for the thingy52 simply:</p> <pre><code>#Within the application directory\nwest build -p auto -b thingy52_nrf52832 </code></pre> <p>the thingy52 can now be flashed with</p> <pre><code>#Within the application directory\nwest flash -r jlink\n</code></pre>"},{"location":"Boards/BRD.3-Dongle_NRF52840/","title":"CSSE4011: nRF Dongle: Zephyr Board Guide","text":""},{"location":"Boards/BRD.3-Dongle_NRF52840/#10-prerequisites","title":"1.0 Prerequisites","text":"<p>Complete following OS tutes</p> <ol> <li>Getting Started</li> <li>First Program</li> </ol>"},{"location":"Boards/BRD.3-Dongle_NRF52840/#11-test-hardware","title":"1.1 Test Hardware","text":"<ul> <li>nRF Dongle</li> </ul>"},{"location":"Boards/BRD.3-Dongle_NRF52840/#20-tools","title":"2.0 Tools","text":"<p>For flashing this board, we need to install <code>nrfutil</code>.</p> <pre><code>pip3 install nrfutil\n\nnrfutil\n</code></pre> <pre><code>Usage: nrfutil [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -v, --verbose            Increase verbosity of output. Can be specified\n                           more than once (up to -v -v -v -v).\n  -o, --output &lt;filename&gt;  Log output to file\n  --help                   Show this message and exit.\n</code></pre>"},{"location":"Boards/BRD.3-Dongle_NRF52840/#21-tty-permissions-for-flashing","title":"2.1 TTY Permissions for Flashing","text":"<p>TTY permissions are required to load the binary by <code>nrfutil</code> . An easy way to do this is to add the current user to the 'dialout' group.</p> <pre><code>sudo usermod -a -G dialout $USER\n</code></pre> <p>You will typically need to log out and log in or reboot to see this effect. </p>"},{"location":"Boards/BRD.3-Dongle_NRF52840/#30-nrf-dongle-nrf52840-zephyr","title":"3.0 nRF Dongle (nRF52840) - Zephyr","text":"<p>To build an application, from within the application directory</p> <pre><code>west build -p auto -b nrf52840dongle_nrf52840\n</code></pre> <p>Package the application for the bootloader using <code>nrfutil</code>:</p> <pre><code>nrfutil pkg generate --hw-version 52 --sd-req=0x00 \\\n--application build/zephyr/zephyr.hex \\\n--application-version 1 blinky.zip\n</code></pre> <p>Now, put the device into bootloader mode, by pressing the sideways push button (next to the white pushbutton). You should see the red led steadily blinky.</p> <pre><code>nrfutil dfu usb-serial -pkg blinky.zip -p /dev/ttyACM0\n</code></pre>"},{"location":"Boards/BRD.3-Dongle_NRF52840/#40-troubleshooting","title":"4.0 Troubleshooting","text":"<p>If you get a permissions error when flashing, it is likely because you did not log out/in after updating groups.</p> <p>If it fails to flash, it could be because the VM does not see the <code>DFU Bootloader</code>.  Run:</p> <p><pre><code>lsusb\n</code></pre> and see if the following comes up</p> <pre><code>Bus 001 Device 009: ID 1915:521f Nordic Semiconductor ASA Open DFU Bootloader\n</code></pre> <p>If not, you will need to edit VM settings and passthrough this USB from the host to the VM.</p>"},{"location":"Boards/BRD.4-Particle_Argon/","title":"CSSE4011: Particle_Boron: Zephyr Board Guide","text":""},{"location":"Boards/BRD.4-Particle_Argon/#10-prerequisites","title":"1.0 Prerequisites","text":"<p>Complete following OS tutes</p> <ol> <li>Getting Started</li> <li>First Program</li> </ol>"},{"location":"Boards/BRD.4-Particle_Argon/#11-test-hardware","title":"1.1 Test Hardware","text":"<ul> <li>Particle Argon</li> <li>2 x mUSB Cable</li> <li>Segger J-Link EDU mini</li> </ul>"},{"location":"Boards/BRD.4-Particle_Argon/#50-install-jlinksoftwaresegger-tools","title":"5.0 Install JLinkSoftware/SEGGER Tools","text":"<p>NOTE: For flashing to work (using Segger JLink devices), you must first install J-Link Software and Documentation pack in your VM, use the <code>64-bit DEB</code> installer for Debian/Ubuntu. </p> <p>To install this, open up a terminal and navigate to download location.</p> <pre><code>cd ~/Downloads\n\n#Make sure the file name is right, versions change often\nsudo dpkg -i JLink_Linux_V762_x86_64.deb\n</code></pre> <p>Make sure that the JLink device is connected up properly to the Thingy52 device, and ensure that the power switch is to the left (facing you - on position). It is a good idea to have the device connected via mUSB for charging during this procedure.</p> <p>Once this has been completed, you can test that it is functional with</p> <pre><code>$ JLinkExe\n</code></pre> <pre><code>SEGGER J-Link Commander V7.62 (Compiled Feb 16 2022 16:09:54)\nDLL version V7.62, compiled Feb 16 2022 16:09:39\n\nConnecting to J-Link via USB...O.K.\nFirmware: J-Link EDU Mini V1 compiled Dec  7 2021 08:38:51\nHardware version: V1.00\nS/N: 801026632\nLicense(s): FlashBP, GDB\nUSB speed mode: Full speed (12 MBit/s)\nVTref=3.286V\n</code></pre> <p>at this point if you get</p> <pre><code>Connecting to J-Link via USB...FAILED: Cannot connect to J-Link.\n</code></pre> <p>This means that either your connections are wrong or more likely that the VM has not been passed the USB from host. You can test this by running.</p> <p><pre><code>lsusb\n\nBus 001 Device 003: ID 1366:0101 SEGGER J-Link PLUS\n</code></pre> If you do not see this device, check if the host can see this device, if so, you will need to configure the VM to allow passthrough for the SEGGER EDU Mini.</p>"},{"location":"Boards/BRD.4-Particle_Argon/#30-build-a-sample-program-blinky-for-the-argon-board","title":"3.0 Build a Sample Program (Blinky) for the Argon Board","text":"<p>If the installation was successful, we should now be able to build a basic blinky program. In the following command, the '-p auto' option automatically cleans byproducts from a previous build if necessary, which is useful if you try building another sample.</p> <p>The '-b' option specifies a board to build for, in this case the particle_argon, followed by the path to the app source. <pre><code>cd ~/csse4011/zephyrproject/zephyr/\n\nwest build -p auto -b particle_argon samples/basic/blinky\n</code></pre> Flash the sample program. Make a sure a 'runner' is connected. You will be given a Segger J-Link device to be used with the Particle Argon. <pre><code>west flash -r jlink\n</code></pre></p> <p>Option '-r' specifies to flash using JLink, west is capable of tapping into different runners for flashing your devices, later we will explore how to specify runners in the CMakeLists file. </p> <p>Additional information for setting up other runners can be found here</p>"},{"location":"Boards/BRD.4-Particle_Argon/#40-example-with-particle-argon-zephyr","title":"4.0 Example with Particle Argon - Zephyr","text":"<p>The particle argon has a simple build and flash procedure. To build for it:</p> <pre><code>#Within the application directory\nwest build -p auto -b particle_argon </code></pre> <p>the argon can now be flashed with</p> <pre><code>#Within the application directory\nwest flash -r jlink\n</code></pre>"},{"location":"Boards/BRD.5-BL475E_IOT/","title":"CSSE4011: B-L475E-IOT: Zephyr Board Guide","text":"<p>Reference: https://docs.zephyrproject.org/3.1.0/boards/arm/disco_l475_iot1/doc/index.html</p>"},{"location":"Boards/BRD.5-BL475E_IOT/#10-prerequisites","title":"1.0 Prerequisites","text":"<p>Complete following OS tutes</p> <ol> <li>Getting Started</li> <li>First Program</li> </ol>"},{"location":"Boards/BRD.5-BL475E_IOT/#11-test-hardware","title":"1.1 Test Hardware","text":"<ul> <li>B-L475E-IOT Board</li> <li>1 x mUSB Cable</li> </ul>"},{"location":"Boards/BRD.5-BL475E_IOT/#20-b-l475e-iot-board-zephyr","title":"2.0 B-L475E-IOT Board - Zephyr","text":"<p>The * B-L475E-IOT Board has a simple build and flash procedure. To build for it:</p> <pre><code>#Within the application directory\nwest build -p auto -b disco_l475_iot1\n</code></pre> <p>the B-L475E-IOT  can now be flashed with</p> <pre><code>#Within the application directory\nwest flash\n</code></pre>"},{"location":"Boards/BRD.6-ESP32C3-devkitm/","title":"CSSE4011: ESP32C3-DevKitM: Zephyr Board Guide","text":"<p>Reference: https://docs.zephyrproject.org/3.1.0/boards/riscv/esp32c3_devkitm/doc/index.html</p>"},{"location":"Boards/BRD.6-ESP32C3-devkitm/#10-prerequisites","title":"1.0 Prerequisites","text":"<p>Complete following OS tutes</p> <ol> <li>Getting Started</li> <li>First Program</li> </ol>"},{"location":"Boards/BRD.6-ESP32C3-devkitm/#11-test-hardware","title":"1.1 Test Hardware","text":"<ul> <li>ESP32C3-DevKitM Board</li> <li>1 x mUSB Cable</li> </ul>"},{"location":"Boards/BRD.6-ESP32C3-devkitm/#20-esp32c3-devkitm-zephyr","title":"2.0 ESP32C3-DevKitM - Zephyr","text":"<p>The * ESP32C3-DevKitM Board has a simple build and flash procedure. To build for it:</p> <pre><code>#Within the application directory\nwest build -p auto -b esp32c3_devkitm\n</code></pre> <p>the ESP32C3-DevKitM   can now be flashed with</p> <pre><code>#Within the application directory\nwest flash\n</code></pre>"},{"location":"Boards/about/","title":"Board Build Guide","text":""},{"location":"Boards/about/#overview","title":"Overview","text":"<p>The following set of tutorials will focus on providing step-by-step instructions for building and flashing a basic Zephyr application on to the following boards</p> <pre><code>1. Thingy52\n2. Arduino Sense (BLE)\n3. Dongle NRF52840\n4. Particle Argon\n</code></pre> <p>The instructions are based on those provided by Zephyr - Board Flashing Guide [1]</p>"},{"location":"Boards/about/#links","title":"Links","text":"<p>[1] https://docs.zephyrproject.org/latest/boards/index.html</p>"},{"location":"Connectivity/CN.1-GPIO/","title":"CSSE4011: Connectivity - GPIO","text":""},{"location":"Connectivity/CN.1-GPIO/#10-motivation","title":"1.0 Motivation","text":"<p>The following tutorial explores exposing the board GPIO (General Purpose Input/Output) to userspace (an app) within Zephyr. Zephyr does things a little differently when it comes to interacting with hardware. In this tutorial, we will use the GPIO API to interact with GPIO pins. </p>"},{"location":"Connectivity/CN.1-GPIO/#11-test-hardware","title":"1.1 Test Hardware","text":"<ul> <li> <p>Particle Argon</p> </li> <li> <p>2 x mUSB Cable</p> </li> <li> <p>Segger J-Link EDU mini</p> </li> </ul> <p>This implementation is valid for Zephyr RTOS Version 3.0.XX</p>"},{"location":"Connectivity/CN.1-GPIO/#12-prerequisites","title":"1.2. Prerequisites","text":"<p>Ensure that you have completed/understand the following tutorials. </p> <ul> <li>OS.1, OS.2, OS.2.1 and BRD.1</li> </ul>"},{"location":"Connectivity/CN.1-GPIO/#13-setup","title":"1.3 Setup","text":"<p>Connect the Arduino sense board to the host machine and ensure that the development environment has access to the device (USB passthrough to virtual machine).</p>"},{"location":"Connectivity/CN.1-GPIO/#20-zephyr-gpio-implementation","title":"2.0 Zephyr GPIO Implementation","text":""},{"location":"Connectivity/CN.1-GPIO/#21-boilerplate","title":"2.1 Boilerplate","text":"<p>The following commands assume that you have setup your files/directories following the respective tutorial(s).</p> <p>Create a new application directory for a sample gpio application. </p> <p><pre><code>cd ~/csse4011/csse4011_repo/\nmkdir -p apps/gpio_sample/\n</code></pre> For setting up a basic boilerplate for our application, we will use the provided blinky sample in Zephyr. </p> <p><pre><code>cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky\ncp -R * ~/csse4011/csse4011_repo/apps/gpio_sample/\ncd ~/csse4011/csse4011_repo/apps/gpio_sample/\n</code></pre> Alternatively, you may create your own application if desired.</p>"},{"location":"Connectivity/CN.1-GPIO/#22-devicetree-summary","title":"2.2 DeviceTree Summary","text":"<pre><code>\"A devicetree is a hierarchical data structure that describes hardware...Zephyr uses devicetree to describe the hardware available on its Supported Boards, as well as that hardware\u2019s initial configuration.\"\n</code></pre> <p>An extensive guide to DeviceTree Source (DTS) implementation can be found here &amp; here. Later in this course, you might need to describe hardware in a DTS overlay file and add it to the build system for Zephyr to access particular hardware that you may need to use. Adding DTS overlays has been covered in <code>OS.2.1-Building_Tips</code>. </p> <p>When an application is built for a particular board, Zephyr creates a final <code>zephyr.dts</code> file in the build directory. This file concatenates all selected hardware into this \"final devicetree\". Typically, it's a good idea to start here to see what the hardware description looks like for the current configuration of your build.</p> <p>For instance, lets try building this boilerplate blinky app for the <code>Particle_Argon</code>. <pre><code>cd ~/csse4011/csse4011_repo/apps/gpio_sample/\nwest  build -p auto -b particle_argon\n</code></pre> Once the build is complete, you can open up the \"final DTS\" (typically used for debugging) at: <pre><code>cd build/zephyr\nvim zephyr.dts\n</code></pre> Here we can see the hardware description for the <code>Particle_Argon</code>. This information is exposed to userland/application in Zephyr, using a set of <code>macros</code> see here.</p> <p>In this tutorial, we are interested in GPIO, so we will look at how to toggle a particular GPIO pin from looking at the <code>zephyr.dts</code> file.</p>"},{"location":"Connectivity/CN.1-GPIO/#22-gpio-interaction","title":"2.2 GPIO Interaction","text":"<p>Typically, when you interact with new hardware, you must first enable the kernel driver for it, this is usually done using a kernel configuration file (KConfig). In our case for GPIO, it is enabled in the <code>prj.conf</code> file in the application directory with <code>CONFIG_GPIO=y</code>. Most boards will typically have basic hardware functionality like gpio, uart and i2c enabled by default in the board definitions (in the Zephyr source). You can refer to <code>OS.2.1-Building_Tips</code> for a guide on adding segmented KConf files to the build system. </p> <p>If you have already read through the blinky sample that we use as boilerplate, you may have already noticed that to toggle the led, it uses the <code>device-tree macros</code> from within the <code>main.c</code> file. </p> <p>For example, <pre><code>/* The devicetree node identifier for the \"led0\" alias. */\n#define LED0_NODE DT_ALIAS(led0)\n#if DT_NODE_HAS_STATUS(LED0_NODE, okay)\n#define LED0    DT_GPIO_LABEL(LED0_NODE, gpios)\n#define PIN     DT_GPIO_PIN(LED0_NODE, gpios)\n#define FLAGS   DT_GPIO_FLAGS(LED0_NODE, gpios)\n</code></pre> Here, <code>DT_ALIAS()</code> is used to find the reference <code>led0</code> within the DTS. This is a special case of using an alias. If we look in the <code>zephyr.dts</code> file, you will notice that <code>led0</code> is specified as <code>aliases{}</code>. So this macro \"returns a node identifier for the node which is aliased\".</p> <p>When you follow the <code>led0</code> alias in <code>zephyr.dts</code>, you will notice that it simply maps to a GPIO pin. Aliases can help abstract the hardware within the devicetree and make them easy to access. </p>"},{"location":"Connectivity/CN.1-GPIO/#24-devicetree-gpio-access","title":"2.4 DeviceTree GPIO Access","text":"<p>Lets investigate toggling a particular GPIO without using it's alias. Why not just make an alias for it? So we can learn how to use <code>DT-Macros</code> in Zephyr.</p> <p>We will use the <code>Particle Argon</code> for this tute. You can find the board pinout here. We will use the GPIO pin <code>P0.13</code> (internally connected to the RGB-red led). This pin maps on <code>P0</code> (port 0), in the <code>zephyr.dts</code> this is <code>gpio0</code>. For instance, pin <code>D6 (p1.11)</code>, will be in <code>gpio1</code>. </p> <p>Start by editing the source file and append the following <pre><code>vim src/main.c\n</code></pre> Use <code>DT_NODELABEL</code> to get the respective node_id for for <code>gpio0</code> from DTS. <pre><code>/* DeviceTree get node ID from label */\n#define GPIO0 DT_NODELABEL(gpio0)\n#define GPIO0_13 0x0D                //PIN PO.13\n</code></pre> In our main function, let's init the GPIO PIN. <pre><code>const struct device *dev_gpio0;\ndev_gpio0 = device_get_binding(DT_LABEL(GPIO0));\n/* Configure PIN_A0 as an Output with that is Active Low */\nret = gpio_pin_configure(dev_gpio0, GPIO0_13, GPIO_OUTPUT_ACTIVE | GPIO_ACTIVE_LOW);\n</code></pre> Notice here, that <code>device_get_binding()</code> will not except a <code>NODE_ID</code>, but it does accept a <code>NODE_LABEL</code>, hence why <code>DT_LABEL</code> is used. <code>DT_LABEL</code> is a helper macro that does the same as <code>DT_PROP(GPIO0, label)</code>. The <code>struct device</code> see here returned by this function call describes the particular hardware and is used by the API to interface to that particular device/hardware. </p> <p>and finally in our while loop, we can toggle this pin.</p> <pre><code>while (1) {\ngpio_pin_set(dev, PIN, (int)led_is_on);\n/* Toggle the PIN */\ngpio_pin_set(dev_gpio0, GPIO0_13, (int)led_is_on);\nled_is_on = !led_is_on;\nk_msleep(SLEEP_TIME_MS);\n}   </code></pre>"},{"location":"Connectivity/CN.1-GPIO/#40-testing","title":"4.0 Testing","text":"<p>This application can now be built and flashed using: <pre><code>west  build -p auto -b particle_argon\nwest flash -r jlink\n</code></pre></p> <p>You should see that the red led is now flashing as well as the blue led (led0) from the boilerplate code (if you didn't remove that code). </p>"},{"location":"Connectivity/CN.1-GPIO/#41-sample-application","title":"4.1 Sample Application","text":"<p>A sample application has been provided, this application includes all the steps mentioned above.</p> <p>Sample is located in:</p> <ul> <li>REPO_TOP/tute_solutions/gpio_sample/</li> </ul>"},{"location":"Connectivity/CN.2-Sensors/","title":"CSSE4011: Connectivity - Sensors","text":""},{"location":"Connectivity/CN.3-Serial_Console/","title":"CSSE4011: Connectivity - Serial Console","text":"<p>The following tutorial will cover the setting up a console through USB with existing Zephyr Drivers. (Note that, USB Debugging/Shell can only be used with platforms that support USB, such as the NRF52840 SoC).</p>"},{"location":"Connectivity/CN.3-Serial_Console/#10-motivation","title":"1.0 Motivation","text":"<p>Once USB console is setup, it can be used for printk() debugging, and/or to examine the internal data structures of an application where required.                     </p>"},{"location":"Connectivity/CN.3-Serial_Console/#11-test-hardware","title":"1.1 Test Hardware","text":"<p>This implementation will explore setting up the console on the Particle Argon.</p> <ul> <li> <p>Particle Argon</p> </li> <li> <p>2 x mUSB Cable</p> </li> <li> <p>Segger J-Link EDU mini</p> </li> </ul> <p>This implementation is valid for Zephyr RTOS Version 3.0.XX</p>"},{"location":"Connectivity/CN.3-Serial_Console/#12-prerequisites","title":"1.2. Prerequisites","text":"<p>Ensure that you have completed/understand the following tutorials. </p> <ul> <li>OS.1, OS.2, OS.2.1 and BRD.1</li> </ul>"},{"location":"Connectivity/CN.3-Serial_Console/#20-setting-up-console","title":"2.0 Setting up Console","text":""},{"location":"Connectivity/CN.3-Serial_Console/#21-boilerplate","title":"2.1 Boilerplate","text":"<p>The following commands assume that you have setup your files/directories following the respective tutorial(s).</p> <p>Create a new application directory for a sample console application. </p> <pre><code>cd ~/csse4011/csse4011_repo/\nmkdir -p apps/console_sample/\n</code></pre> <p>For setting up a basic boilerplate for our application, we will use the provided blinky sample in Zephyr. </p> <pre><code>cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky\ncp -R * ~/csse4011/csse4011_repo/apps/console_sample/\ncd ~/csse4011/csse4011_repo/apps/console_sample/\n</code></pre>"},{"location":"Connectivity/CN.3-Serial_Console/#22-enable-usb-drivers-prjconf","title":"2.2 Enable USB Drivers [prj.conf]","text":"<p>To enable the existing USB drivers, a few config options need to be added to our project. A detailed guide for the USB API is found here, which you may need to refer to for additional information. </p> <p>Start by editing the prj.conf file. Append the following config options. These options can be found here, for different subsystems.  <pre><code>CONFIG_GPIO=y\n\n#------------------------------ENABLE USB---------------------------------------\n#Add this line if building for the Arduino Sense Board\n#CONFIG_BOARD_ARDUINO_NANO_33_BLE_EN_USB_CONSOLE=y\nCONFIG_USB_DEVICE_STACK=y\nCONFIG_USB_DEVICE_PRODUCT=\"USB Console Tute\"\n\nCONFIG_SERIAL=y\nCONFIG_CONSOLE=y\nCONFIG_UART_CONSOLE=y\nCONFIG_UART_LINE_CTRL=y\n#------------------------------------------------------------------------------\n</code></pre> Optionally, you can add the following config statements to add some flavour to the USB Stack... These commands let you set USB device ID parameters. </p> <pre><code>#--------------------------------USB OPTIONS----------------------------------\nCONFIG_USB_DEVICE_PRODUCT=\"Particle Argon - Zephyr\"\nCONFIG_USB_DEVICE_MANUFACTURER=\"Wilfred MK\"\nCONFIG_USB_DEVICE_VID=0xC553\nCONFIG_USB_DEVICE_PID=0x4011\n#-----------------------------------------------------------------------------\n</code></pre>"},{"location":"Connectivity/CN.3-Serial_Console/#23-setting-up-cdc-acm-appoverlay","title":"2.3 Setting up CDC-ACM [app.overlay]","text":"<p>Zephyr v2.7/3.0 requires an overlay file to be added to specify Communication Device Class - Abstract Control Model (CDC-ACM). The CDC ACM can be used as backends for Zephyr Subsystems, such as console and shell. </p> <p>There is detailed information about how an overlay is implemented and it's purpose in this sub-system which can be found here. </p> <p>For this particular example, start by making an app.overlay. If there exists a file named app.overlay in the app directory, it get added to the build system by default (See here, for device tree overlays). </p> <pre><code>cd ~/csse4011/csse4011_repo/apps/console_sample/        #App Directory\nvim app.overlay                                         #Use any text editor\n</code></pre> <p>Copy the following overlay details into the newly created file. This is adding a devicetree overlay to the build system, see here for more. Here we specify the console should be routed to cdc_acm_uart0.</p> <pre><code>/ {\nchosen {\nzephyr,console = &amp;cdc_acm_uart0;\n};\n};\n&amp;zephyr_udc0 {\ncdc_acm_uart0: cdc_acm_uart0 {\ncompatible = \"zephyr,cdc-acm-uart\";\nlabel = \"CDC_ACM_0\";\n};\n};\n</code></pre>"},{"location":"Connectivity/CN.3-Serial_Console/#24-initializing-the-driver-mainc","title":"2.4 Initializing the Driver [main.c]","text":"<p>At this point, ensure that there are no compile errors by running <pre><code>west build -p -b particle_argon\n</code></pre></p> <p>and now we tell our application to initialize the USB and print some data.</p> <p><pre><code>vim src/main.c\n</code></pre> <pre><code>#include &lt;usb/usb_device.h&gt;\n#include &lt;drivers/uart.h&gt;       //Include these libraries\n//Add the following to main()\nvoid\nmain(void)\n{\n/* Setup DTR */\nconst struct device *console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));\nuint32_t dtr = 0;\n/* Enable the USB Driver */\nif (usb_enable(NULL))   return;\n/* Wait on DTR - 'Data Terminal Ready'\n    * Will wait here until a terminal has been attached to the device\n    * This is not necessary, however, can be useful for printing boot info etc..\n    */\nwhile (!dtr) {\nuart_line_ctrl_get(console_dev, UART_LINE_CTRL_DTR, &amp;dtr);\nk_sleep(K_MSEC(100));\n}\nwhile(1)\n{\nprintk(\"Hello World\\n\");\nk_sleep(K_MSEC(500));\n}\n}\n</code></pre></p>"},{"location":"Connectivity/CN.3-Serial_Console/#25-testing","title":"2.5 Testing","text":"<p>This application can now be built and flashed using: <pre><code>west  build -p auto -b particle_argon\nwest flash -r jlink   </code></pre></p> <p>Since this is now a 'new usb device', you will need to pass through USB from your host machine to the VM to open the console within your CSSE4011 VM Typically, you might have to unplug and reconnect the device for the pass through to take effect. Alternatively, you should be able to view the console on the host machine also.</p> <p>See that the device is connected  <pre><code>lsusb  #Command to show currently attached USB devices\n#You will see this if you added the USB OPTIONS from above\nBus 001 Device 099: ID c553:4011 Wilfred MK Particle Argon - Zephyr\n</code></pre></p> <p>First install screen (App that can monitor terminal) <pre><code>sudo apt-get install screen\n</code></pre> <pre><code>sudo screen /dev/ttyACM0\n\nHello World\nHello World\nHello World\n</code></pre></p>"},{"location":"Connectivity/CN.3-Serial_Console/#26-sample-application","title":"2.6 Sample Application","text":"<p>A sample application has been provided, this application includes all the steps mentioned above. You can test the console by flashing it to the Particle Argon Board.</p> <p>Sample is located in:</p> <ul> <li>REPO_TOP/tute_solutions/console_example/</li> </ul>"},{"location":"Connectivity/CN.4-Shell/","title":"CSSE4011: Connectivity - Shell","text":"<p>The following tutorial will cover the setting up a command line interface/Shell through USB with existing Zephyr Drivers. (Note that, USB Debugging/Shell can only be used with platforms that support USB, such as the NRF52840 SoC).</p>"},{"location":"Connectivity/CN.4-Shell/#10-motivation","title":"1.0 Motivation","text":"<p>A shell or a command line interface (CLI) allows for a user to interact with the OS in real time. Shell commands can be used to issue unique commands to a device or change application logic. For example, a command to read run-time statistics of threads or to turn an led on or off etc...</p> <p>Zephyr also allows for Shell to be used as a backend for the Zephyr Logging API. The logging API is explored in CN.5-Logging.</p>"},{"location":"Connectivity/CN.4-Shell/#11-test-hardware","title":"1.1 Test Hardware","text":"<p>This implementation will explore setting up shell on the Particle Argon.</p> <ul> <li> <p>Particle Argon</p> </li> <li> <p>2 x mUSB Cable</p> </li> <li> <p>Segger J-Link EDU mini</p> </li> </ul> <p>This implementation is valid for Zephyr RTOS Version 3.0.XX</p>"},{"location":"Connectivity/CN.4-Shell/#12-prerequisites","title":"1.2. Prerequisites","text":"<p>Ensure that you have completed/understand the following tutorials. </p> <ul> <li>OS.1, OS.2, OS.2.1 and BRD.1</li> </ul>"},{"location":"Connectivity/CN.4-Shell/#13-setup","title":"1.3 Setup","text":"<p>Connect the Particle Argon board to the host machine and ensure that the development environment has access to the device (USB passthrough to virtual machine).</p>"},{"location":"Connectivity/CN.4-Shell/#20-zephyr-shell-implementation","title":"2.0 Zephyr Shell Implementation","text":""},{"location":"Connectivity/CN.4-Shell/#21-boilerplate","title":"2.1 Boilerplate","text":"<p>The following commands assume that you have setup your files/directories following the respective tutorial(s).</p> <p>Create a new application directory for a sample shell application. </p> <pre><code>    cd ~/csse4011/csse4011_repo/\n    mkdir -p apps/shell_sample/\n</code></pre> <p>For setting up a basic boilerplate for our application, we will use the provided blinky sample in Zephyr. </p> <pre><code>    cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky\n    cp -R * ~/csse4011/csse4011_repo/apps/shell_sample/\n    cd ~/csse4011/csse4011_repo/apps/shell_sample/\n</code></pre>"},{"location":"Connectivity/CN.4-Shell/#22-enable-usb-drivers-prjconf","title":"2.2 Enable USB Drivers [prj.conf]","text":"<p>To show a more structure approach to setting configs in Zephyr, in this tutorials we will explore the addition of segmented config files to the build system. Where each file represents a different subsystem. Such an approach improves modularity for bigger projects. </p> <p>First, we will enable the USB subsystem as before, </p> <p>These options can be found here, for diffrent subsystems.</p> <p><pre><code>vim usb.conf  #create a new .conf file for the USB subsystem\n</code></pre> Append the following, then save and exit the editor. <pre><code>#----------------------------------USB SETUP----------------------------------\nCONFIG_USB_DEVICE_STACK=y\nCONFIG_USB_DEVICE_PRODUCT=\"Zephyr USB shell sample\"\n#-----------------------------------------------------------------------------\n\n#--------------------------------USB_OPTIONS----------------------------------\nCONFIG_USB_DEVICE_PRODUCT=\"Particle Argon - Zephyr\"\nCONFIG_USB_DEVICE_MANUFACTURER=\"Wilfred MK\"\nCONFIG_USB_DEVICE_VID=0xC553\nCONFIG_USB_DEVICE_PID=0x4011\n#-----------------------------------------------------------------------------\n</code></pre> Next, we will enable Zephyr Shell, </p> <p><pre><code>vim shell.conf #create a new .conf file for shell options\n</code></pre> append the following config settings. <pre><code>#-----------------------------SHELL_CONF--------------------------------------\nCONFIG_SHELL_BACKEND_SERIAL_CHECK_DTR=y\nCONFIG_UART_LINE_CTRL=y\nCONFIG_SHELL_BACKEND_SERIAL_INIT_PRIORITY=51\nCONFIG_SHELL=y\nCONFIG_SHELL_BACKENDS=y\nCONFIG_SHELL_BACKEND_SERIAL=y\n\nCONFIG_SHELL_PROMPT_UART=\"CSSE4011:~$\"\n\nCONFIG_SHELL_CMDS=y\nCONFIG_SHELL_TAB=y\nCONFIG_SHELL_TAB_AUTOCOMPLETION=y\nCONFIG_SHELL_VT100_COLORS=y\nCONFIG_KERNEL_SHELL=y\n#-----------------------------------------------------------------------------\n\n#-----------------------------SHELL_LOGGING-----------------------------------\nCONFIG_LOG=y\nCONFIG_LOG_PRINTK=y\n#-----------------------------------------------------------------------------\n</code></pre> Save the file and exit the editor.</p>"},{"location":"Connectivity/CN.4-Shell/#23-shell-usb-overlay","title":"2.3 Shell USB Overlay","text":"<p>As with the console, we must inform Zephyr that the shell-uart is to be routed through the USB subsystem using CDC_ACM. This can be done by creating and adding an overlay file to the build-system. An 'app.overlay' file can be created similarly to the console tutorial, and this will automatically be picked up by the build-system. However, here we will explore manually adding it to the build system. </p> <p><pre><code>vim dtc_shell.overlay #create new file for shell overlay\n</code></pre> append the following to the file. <pre><code>/ {\nchosen {\nzephyr,shell-uart = &amp;cdc_acm_uart0;\n};\n};\n&amp;zephyr_udc0 {\ncdc_acm_uart0: cdc_acm_uart0 {\ncompatible = \"zephyr,cdc-acm-uart\";\nlabel = \"CDC_ACM_0\";\n};\n};\n</code></pre> Save and exit the editor.</p>"},{"location":"Connectivity/CN.4-Shell/#24-adding-files-to-cmakelists","title":"2.4 Adding files to CMakeLists","text":"<p>At this point, we have created our config/overlay files. We must add these to our build system for any of them to take effect (if a file is named app.conf, it is picked up by the build system by default, as seen in CN.3-Serial_Console). More details on this can be found here.</p> <p><pre><code>vim CMakeLists.txt\n</code></pre> At the top of the file, append the following to add the newly created config files to CMakeLists. <pre><code>set(CONF_FILE usb.conf shell.conf)\nset(DTC_OVERLAY_FILE dtc_shell.overlay)\n</code></pre></p>"},{"location":"Connectivity/CN.4-Shell/#25-initializing-the-driver-mainc","title":"2.5 Initializing the Driver [main.c]","text":"<p>At this point, ensure that there are no compile errors by running <pre><code>west build -p -b particle_argon\n</code></pre></p> <p>and now we tell our application to initialize the USB stack.</p> <p><pre><code>vim src/main.c\n</code></pre> <pre><code>#include &lt;usb/usb_device.h&gt;\n#include &lt;drivers/uart.h&gt;       //Include these libraries\n//Add the following to main()\nvoid\nmain(void)\n{\n/* Setup DTR */\nconst struct device *shell_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_shell_uart));\nuint32_t dtr = 0;\n/* Enable the USB Driver */\nif (usb_enable(NULL))   return;\n/* Wait on DTR - 'Data Terminal Ready'\n    * Will wait here until a terminal has been attached to the device\n    * This is not necessary, however, can be useful for printing boot info etc..\n    */\nwhile (!dtr) {\nuart_line_ctrl_get(shell_dev, UART_LINE_CTRL_DTR, &amp;dtr);\nk_sleep(K_MSEC(100));\n}\nwhile(1)\n{\n//printk(\"Hello World\\n\");  //This will get routed to the shell also (optional)\nk_sleep(K_MSEC(500));\n}\n}\n</code></pre></p>"},{"location":"Connectivity/CN.4-Shell/#26-testing","title":"2.6 Testing","text":"<p>This application can now be built and flashed using: <pre><code>west  build -p auto -b particle_argon\nwest flash -r jlink   </code></pre> Since this is now a 'new usb device', you will need to pass through USB from your host machine to the VM to open the shell within your CSSE4011 VM Typically, you might have to unplug and reconnect the device for the pass through to take effect. Alternatively, you should be able to view the shell on the host machine also.</p> <p>See that the device is connected  <pre><code>lsusb  #Command to show currently attached USB devices\n#You will see this if you added the USB OPTIONS from above\nBus 001 Device 099: ID c553:4011 Wilfred MK Particle Argon - Zephyr\n</code></pre></p> <p>First install screen (App that can monitor terminal) <pre><code>sudo apt-get install screen\n</code></pre> <pre><code>sudo screen /dev/ttyACM0\n</code></pre> You can press 'tab' to see the currently enabled options through shell. <pre><code>[00:00:11.851,226] &lt;inf&gt; usb_cdc_acm: Device resumed\n[00:00:11.851,257] &lt;inf&gt; usb_cdc_acm: from suspend\nCSSE4011:~$\n  clear              device             devmem             help\n  history            hwinfo             kernel             log\n  nrf_clock_control  resize             shell\n</code></pre></p> <pre><code>CSSE4011:~$kernel threads\nScheduler: 23890 since last call\nThreads:\n*0x20000438 shell_uart\n        options: 0x0, priority: 14 timeout: 536872112\n        state: queued, entry: 0x13029\n        stack size 2048, unused 1176, usage 872 / 2048 (42 %)\n</code></pre>"},{"location":"Connectivity/CN.4-Shell/#27-sample-application","title":"2.7 Sample Application","text":"<p>A sample application has been provided, this application includes all the steps mentioned above. You can test the shell by flashing it to the Particle Argon.</p> <p>Sample is located in:</p> <ul> <li>REPO_TOP/tute_solutions/shell_example/</li> </ul>"},{"location":"Connectivity/CN.4.1-Shell_Commands/","title":"CSSE4011: Connectivity - Shell Commands","text":"<p>This tutorial aims to introduce adding shell commands to the Zephyr shell that we explored in  <code>CN.4-Shell</code>.</p>"},{"location":"Connectivity/CN.4.1-Shell_Commands/#10-motivation","title":"1.0 Motivation","text":"<p>To get the most out of an application that implement a shell, it is often useful to add specific functionality. By adding application specific shell commands, specific features of an application can be exposed to a user/developer. </p> <p>Typically, a command will <code>hook</code> into a <code>piece of code</code> or a <code>callback function</code> and execute some functionality for that command. For instance, in a embedded application, if the user aims to turn some hardware off, you could issue a shell command to the device to carry this out, or if you wanted to get a reading from a sensor and print it to the shell, you could issue a command to do this. Similar to how in a unix based shell you would issue commands to interact/request services from the OS.</p>"},{"location":"Connectivity/CN.4.1-Shell_Commands/#11-test-hardware","title":"1.1 Test Hardware","text":"<ul> <li> <p>Particle Argon</p> </li> <li> <p>2 x mUSB Cable</p> </li> <li> <p>Segger J-Link EDU mini</p> </li> </ul> <p>This implementation is valid for Zephyr RTOS Version 3.0.XX</p>"},{"location":"Connectivity/CN.4.1-Shell_Commands/#12-prerequisites","title":"1.2. Prerequisites","text":"<p>Ensure that you have completed/understand the following tutorials. </p> <ul> <li>OS.1, OS.2, OS.2.1, BRD.1 and CN.4-Shell</li> </ul>"},{"location":"Connectivity/CN.4.1-Shell_Commands/#13-setup","title":"1.3 Setup","text":"<p>Connect the Particle Argon board to the host machine and ensure that the development environment has access to the device (USB passthrough to virtual machine). </p>"},{"location":"Connectivity/CN.4.1-Shell_Commands/#20-zephyr-shell-command-implementation","title":"2.0 Zephyr Shell Command Implementation","text":""},{"location":"Connectivity/CN.4.1-Shell_Commands/#21-boilerplate","title":"2.1 Boilerplate","text":"<p>In the previous tutorial <code>(CN.4 - Shell)</code> we set up the Zephyr Shell through USB. We will use that as our boilerplate for this tutorial and add to it the functionality required to implement shell commands.</p> <p>The following commands assume that you have setup your files/directories following the respective tutorial(s).</p> <p><pre><code>cd ~/csse4011/csse4011_repo/apps\nmkdir shell_cmd_sample/\n</code></pre> Copy shell sample files (from <code>CN.4 - Shell</code>) into new directory for shell commands <pre><code>cd -R shell_sample/* shell_cmd_sample/\n</code></pre></p>"},{"location":"Connectivity/CN.4.1-Shell_Commands/#21-implementing-a-shell-command","title":"2.1 Implementing a Shell Command","text":"<p>In this tutorial, we will explore using shell commands, to toggle on and off the onboard led. This should give you a general idea of how commands should be implemented/used. For more information on the following see here.</p> <p>Zephyr allows you to create commands that have sub-commands, these can be useful for instance, if you wanted a top level command (<code>root command - level 0</code>) for a particular sub-system/hardware, and then sub-commands (<code>static/dynamic sub-commands - level &gt; 0</code>) that perform unique a function for that system. It can be thought of as a tree of commands.</p> <p>Here, we will look at creating a root command (led) with two static commands (on/off). However, you can refer here [1] for the api guide for more information on other types of commands.</p> <p>First, </p> <p><pre><code>cd shell_cmd_sample/\nvim src/main.c\n</code></pre> add the shell include <pre><code>#include &lt;shell/shell.h&gt;\n</code></pre></p> <p>Now we can specify what commands we are going to make, using the Shell API macros <code>SHELL_CMD_REGISTER()</code> and <code>SHELL_STATIC_SUBCMD_SET_CREATE()</code></p> <p>Let's first declare some prototype handlers for our commands <pre><code> /* Declare command handler prototypes */\nstatic int cmd_led_ctrl_on(const struct shell *, size_t, char **);\nstatic int cmd_led_ctrl_off(const struct shell *, size_t, char **);\n</code></pre> and let's use the macros to setup our commands. <pre><code>/* Specify Shell Commands for LED Toggling */\n/* Creating subcommands (level 1 command) array for command \"led\". */ SHELL_STATIC_SUBCMD_SET_CREATE(led_ctrl,\nSHELL_CMD(on, NULL, \"Turn led on.\", cmd_led_ctrl_on),\nSHELL_CMD(off,   NULL, \"Turn led off.\", cmd_led_ctrl_off),\nSHELL_SUBCMD_SET_END\n); /* Creating root (level 0) command \"led\" */\nSHELL_CMD_REGISTER(led, &amp;led_ctrl, \"Led Control (On/Off)\", NULL);\n</code></pre> <code>SHELL_CMD_REGISTER()</code> creates out root level command for <code>led</code>, and <code>SHELL_STATIC_SUBCMD_SET_CREATE()</code> create the level 1 subcommands for <code>on</code> and <code>off</code>, which are linked to their respective command handlers <code>cmd_led_ctrl_on</code> and <code>cmd_led_ctrl_off</code>. That is, when a user types <code>led off</code>, the <code>cmd_led_ctrl_off</code> is triggered.</p> <p>Finally, we can implement the actual handlers. Note, that these don't check if the <code>led-gpio pin</code> has been initialized and assumes it has been pre-configured in <code>main()</code> (if not, <code>gpio_pin_set()</code> will fail). </p> <p><pre><code>/* Command Handler for toggling led0 on, note that it assumes\n * the pin has been preconfigured */\nstatic int cmd_led_ctrl_on(const struct shell *shell, size_t argc,\nchar **argv)\n{\nARG_UNUSED(argc);\nARG_UNUSED(argv);\nconst struct device *dev = device_get_binding(LED0);\nif (dev == NULL) {\nreturn ENODEV;\n}\nreturn gpio_pin_set(dev, PIN, 1);\n}\n/* Command Handler for toggling led0 off, note that it assumes\n * the pin has been preconfigured */\nstatic int cmd_led_ctrl_off(const struct shell *shell, size_t argc,\nchar **argv)\n{\nARG_UNUSED(argc);\nARG_UNUSED(argv);\nconst struct device *dev = device_get_binding(LED0);\nif (dev == NULL) {\nreturn ENODEV;\n}\nreturn gpio_pin_set(dev, PIN, 0);\n}\n</code></pre> Since we copied the boilerplate from <code>CN-4 Shell</code>, make sure to cleanup the <code>while()</code> loop in <code>main()</code> that toggles the gpio, but leave the code that initializes the <code>led-gpio pin</code>. Alternatively, you could make two other subcommands to init/deinit the pin.</p>"},{"location":"Connectivity/CN.4.1-Shell_Commands/#22-testing","title":"2.2 Testing","text":"<p>Once you have built and flashed the application, attach <code>screen</code> to the device. In the shell, you can press <code>tab</code> to show available commands. You should be able to see one that says <code>led</code> now. Try <code>led --help</code> to see what it can do, then, <code>led on</code>, this should turn the led on.</p> <pre><code>[00:00:00.234,588] &lt;inf&gt; usb_cdc_acm: Device resumed\n[00:00:00.429,962] &lt;inf&gt; usb_cdc_acm: Device configured\nCSSE4011:~$\n  clear              device             devmem             help\n  history            hwinfo             kernel             led\n  log                nrf_clock_control  resize             shell\nCSSE4011:~$led --help\nled - Led Control (On/Off)\nSubcommands:\n  on   :Turn led on.\n  off  :Turn led off.\nCSSE4011:~$\nCSSE4011:~$led off\nCSSE4011:~$led on\n</code></pre>"},{"location":"Connectivity/CN.4.1-Shell_Commands/#30-sample-application","title":"3.0 Sample Application","text":"<p>A sample application has been provided, this application includes all the steps mentioned above. You can test the shell commands to toggle the onboard led by flashing it to the Particle Argon Board.</p> <p>Sample is located in:</p> <ul> <li>REPO_TOP/tute_solutions/shell_cmd_sample/</li> </ul>"},{"location":"Connectivity/CN.5-Logging/","title":"CSSE4011: Connectivity - Loggging","text":""},{"location":"Connectivity/CN.5-Logging/#10-motivation","title":"1.0 Motivation","text":"<p>The aim of this tutorial is to introduce the Zephyr Logging Api. Logging in an application can be used for for implementing debugging, providing status updates and other general information. </p> <p>In complex systems, logging is often implemented and is a fundamental part of providing a robust application. Using the Zephyr logging api, this tutorial will introduce how to implement logging in an application. </p> <p>Typically, logging is coupled with a command line interface. In addition to the previous tutorial CN.4-Shell, we will append the logging subsystem on to our shell.</p>"},{"location":"Connectivity/CN.5-Logging/#11-test-hardware","title":"1.1 Test Hardware","text":"<ul> <li> <p>Particle Argon</p> </li> <li> <p>2 x mUSB Cable</p> </li> <li> <p>Segger J-Link EDU mini</p> </li> </ul> <p>This implementation is valid for Zephyr RTOS Version 3.0.XX</p>"},{"location":"Connectivity/CN.5-Logging/#12-prerequisites","title":"1.2. Prerequisites","text":"<p>Ensure that you have completed/understand the following tutorials. </p> <ul> <li>OS.1, OS.2, OS.2.1 , BRD.1 and CN.4-Shell. </li> </ul>"},{"location":"Connectivity/CN.5-Logging/#20-zephyr-logging-implementation","title":"2.0 Zephyr Logging Implementation","text":""},{"location":"Connectivity/CN.5-Logging/#21-boilerplate","title":"2.1 Boilerplate","text":"<p>The following commands assume that you have setup your files/directories following the respective tutorial(s).</p> <p>Create a new application directory for a sample shell application. </p> <pre><code>cd ~/csse4011/csse4011_repo/\nmkdir -p apps/logging_sample/\n</code></pre> <p>Here we will a copy of the previous shell sample and add to it. You may also use the provided shell solution.</p> <pre><code>cd shell_example/\ncp -R * ../shell_sample/\ncd ~/csse4011/csse4011_repo/apps/shell_sample/\n</code></pre>"},{"location":"Connectivity/CN.5-Logging/#22-driver-and-config-setup","title":"2.2 Driver and Config Setup","text":"<p>Since we are appending to our existing solution of the shell sample, we do need additional overlays or config options here. It is worth noting that in <code>shell.conf</code> the following lines enable logging. Here, the shell is set default as the backend for logging (preset in Kconfig options: <code>CONFIG_SHELL_LOG_BACKEND</code> [1]).</p> <pre><code>#-----------------------------SHELL_LOGGING-----------------------------------\nCONFIG_LOG=y\nCONFIG_LOG_PRINTK=y\n#-----------------------------------------------------------------------------\n</code></pre> <p>This also shows the simplicity of Zephyr, once an application is setup, using Zephyr features is as simple as adding config options (for the most part anyway...)!</p>"},{"location":"Connectivity/CN.5-Logging/#30-using-the-logging-api","title":"3.0 Using the Logging API","text":"<p>The API guide for logging can be found here, it is suggested that you read through it and understand the implementation options that logging can provide.</p>"},{"location":"Connectivity/CN.5-Logging/#31-register-a-module","title":"3.1 Register a Module","text":"<p>A <code>log module</code> must be declared prior to using logging in an application. These modules may represent a device driver or a particular sub-system. For instance, you may define a module for a particular temperature sensor driver -- any logged output from this driver will now contain a signature referring to the name of the respective module. </p> <p>Since we only have the one source file, we will define only one module. The API guide has more information on how to use this across multiple files using different macros. It is simple to setup and highly suggested for your projects. </p> <p>Start by editing our source file.  <pre><code>vim src/main.c\n</code></pre> append the following. <pre><code>#include &lt;logging/log.h&gt;\n/* Define logging module */\nLOG_MODULE_REGISTER(sample_module);\n//OR\nLOG_MODULE_REGISTER(sample_module, LOG_LEVEL_DBG);\n</code></pre></p> <p>This registers a module names <code>sample_module</code> with a log filter level of <code>DEBUG</code> (this is optional). </p>"},{"location":"Connectivity/CN.5-Logging/#32-using-a-module","title":"3.2 Using a Module","text":"<p>Once a module as been registered as above, we can use the following macros to implement the logging. Keep in mind that if you have set a <code>LOG_LEVEL_X</code> some of these may be filtered out.</p> <pre><code>LOG_ERR(\"Some error message: %d\", errno);\nLOG_WRN(\"It's getting hot in here...\");\nLOG_INF(\"The table is made out of...table\");\nLOG_DBG(\"Read 0x8F register value: %ld\", rVal);\n</code></pre> <p>Refer to the API guide, for more useful logging macros. </p> <p>In our <code>main.c</code> file, we can add in some logging options. </p> <pre><code>...\n...\nwhile (1) {\ngpio_pin_set(dev, PIN, (int)led_is_on);\nled_is_on = !led_is_on;\nLOG_INF(\"Led is currently: %s\", led_is_on ? \"On\" : \"Off\");\nk_sleep(K_SECONDS(5));\n}\n</code></pre>"},{"location":"Connectivity/CN.5-Logging/#40-testing","title":"4.0 Testing","text":"<p>This application can now be built and flashed using: <pre><code>west  build -p auto -b particle_argon\nwest flash -r jlink </code></pre></p> <p>Once flashed, <pre><code>sudo screen /dev/ttyACM0\n</code></pre></p> <pre><code>...\n...\n[00:00:03.203,369] &lt;dbg&gt; sample_module.main: DTR OK\n[00:00:03.203,369] &lt;inf&gt; sample_module: Led is currently: Off\n[00:00:08.203,430] &lt;inf&gt; sample_module: Led is currently: On\n</code></pre>"},{"location":"Connectivity/CN.5-Logging/#41-sample-application","title":"4.1 Sample Application","text":"<p>A sample application has been provided, this application includes all the steps mentioned above. You can test the shell by flashing it to the Particle Argon.</p> <p>Sample is located in:</p> <ul> <li>REPO_TOP/tute_solutions/logging_example/</li> </ul>"},{"location":"Connectivity/CN.6-Segger_RTT/","title":"CSSE4011: Connectivity - Using Segger RTT","text":""},{"location":"Connectivity/CN.6-Segger_RTT/#10-motivation","title":"1.0 Motivation","text":"<p>Aim of this tutorial is to use Segger RTT for serial access on devices where USB is not available. For instance, the Thingy52, has an nRF52832 SOC, which does not support USB-D. To debug such a device, where a JTAG is exposed, we can configure the Zephyr kernel to backend a shell or a console to Segger RTT. </p>"},{"location":"Connectivity/CN.6-Segger_RTT/#11-test-hardware","title":"1.1 Test Hardware","text":"<ul> <li> <p>Thingy52 or Particle Argon </p> </li> <li> <p>2x mUSB Cable</p> </li> <li> <p>Segger JLinkEDUMini</p> </li> </ul>"},{"location":"Connectivity/CN.6-Segger_RTT/#12-prerequisites","title":"1.2. Prerequisites","text":"<p>Ensure that you have completed/understand the following tutorials. </p> <ul> <li>OS.1, OS.2, OS.2.1 and BRD.2</li> </ul>"},{"location":"Connectivity/CN.6-Segger_RTT/#13-setup","title":"1.3 Setup","text":"<p>Connect the the JLinkEdu mini to the Thingy52 and to your VM (with USB passthrough). Make sure that the Thingy52 is powered on (switch in left position, when looking directly at it) and connected to a PC for charging the battery.</p>"},{"location":"Connectivity/CN.6-Segger_RTT/#20-zephyr-console-segger-rtt-implementation","title":"2.0 Zephyr Console - Segger RTT  Implementation","text":"<p>The following commands assume that you have setup your files/directories following the respective tutorial(s).</p>"},{"location":"Connectivity/CN.6-Segger_RTT/#21-boilerplate","title":"2.1 Boilerplate","text":"<p>Start by making setting up a sample Zephyr application as we have done before. You could use the <code>blinkly</code> provided sample in the Zephyr source.</p> <p><pre><code>cd ~/csse4011/csse4011_repo/apps\nmkdir segger_rtt_console/\n</code></pre> Use the boilerplate from blinky to setup the application directory</p> <pre><code>cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky\ncp -R * ~/csse4011/csse4011_repo/apps/segger_rtt_console/\ncd ~/csse4011/csse4011_repo/apps/segger_rtt_console/\n</code></pre>"},{"location":"Connectivity/CN.6-Segger_RTT/#22-add-segger-rtt-kconf-for-console","title":"2.2 Add Segger RTT KConf for Console","text":"<p>We'll create a new config file. <pre><code>vim segger_rtt_console.conf\n</code></pre> and add in: <pre><code>#-----------------------------RTT_CONFIG--------------------------------------\nCONFIG_USE_SEGGER_RTT=y\n\nCONFIG_RTT_CONSOLE=y\nCONFIG_UART_CONSOLE=n\n#-----------------------------------------------------------------------------\n</code></pre></p>"},{"location":"Connectivity/CN.6-Segger_RTT/#23-add-kconf-to-cmakelists","title":"2.3 Add KConf to CMakeLists","text":"<p>Now, we will add these to the build system (as per <code>OS2.1 - Building Tips</code>) <pre><code>vim CMakeLists.txt\n\nset(CONF_FILE segger_rtt_console.conf)\n</code></pre> Now you can compile and flash this application. See below <code>4.0 Testing</code> for more. Be sure to add a <code>printk()</code>, so you can see some output in the console.</p> <pre><code>while(1) {\nprintk(\"Out like a light\\n\");\nk_msleep(500);\n}\n</code></pre>"},{"location":"Connectivity/CN.6-Segger_RTT/#30-zephyr-shell-segger-rtt-implementation","title":"3.0 Zephyr Shell - Segger RTT  Implementation","text":"<p>The following commands assume that you have setup your files/directories following the respective tutorial(s).</p>"},{"location":"Connectivity/CN.6-Segger_RTT/#31-boilerplate","title":"3.1 Boilerplate","text":"<p>Start by making setting up a sample Zephyr application as we have done before. You could use the <code>blinkly</code> provided sample in the Zephyr source.</p> <p><pre><code>cd ~/csse4011/csse4011_repo/apps\nmkdir segger_rtt_shell/\n</code></pre> Use the boilerplate from blinky to setup the application directory</p> <pre><code>cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky\ncp -R * ~/csse4011/csse4011_repo/apps/segger_rtt_shell/\ncd ~/csse4011/csse4011_repo/apps/segger_rtt_shell/\n</code></pre>"},{"location":"Connectivity/CN.6-Segger_RTT/#32-add-segger-rtt-kconf-for-shell","title":"3.2 Add Segger RTT KConf for Shell","text":"<p>We'll create a new config file. <pre><code>vim segger_rtt_shell.conf\n</code></pre> And add these options into tell the kernel we want to use these features. <pre><code>#-----------------------------RTT_CONFIG--------------------------------------\nCONFIG_USE_SEGGER_RTT=y\nCONFIG_SHELL_BACKEND_RTT=y\n#-----------------------------------------------------------------------------\n</code></pre> Since we are using the shell, we will also need to configure it (same config as in <code>CN.4 - Shell</code>). To summarize: <pre><code>vim shell.conf\n</code></pre> and add the following <pre><code>#-----------------------------SHELL_CONF--------------------------------------\nCONFIG_SHELL_BACKEND_SERIAL_CHECK_DTR=y\nCONFIG_UART_LINE_CTRL=y\nCONFIG_SHELL_BACKEND_SERIAL_INIT_PRIORITY=51\nCONFIG_SHELL=y\nCONFIG_SHELL_BACKENDS=y\nCONFIG_SHELL_BACKEND_SERIAL=y\n\nCONFIG_SHELL_PROMPT_RTT=\"CSSE4011:~$\"\n\nCONFIG_SHELL_CMDS=y\nCONFIG_SHELL_TAB=y\nCONFIG_SHELL_TAB_AUTOCOMPLETION=y\nCONFIG_SHELL_VT100_COLORS=y\nCONFIG_KERNEL_SHELL=y\n#-----------------------------------------------------------------------------\n\n#-----------------------------SHELL_LOGGING-----------------------------------\nCONFIG_LOG=y\nCONFIG_LOG_PRINTK=y\n#-----------------------------------------------------------------------------\n</code></pre></p>"},{"location":"Connectivity/CN.6-Segger_RTT/#33-add-kconf-to-cmakelists","title":"3.3 Add KConf to CMakeLists","text":"<p>Now, we will add these to the build system (as per <code>OS2.1 - Building Tips</code>) <pre><code>vim CMakeLists.txt\n\nset(CONF_FILE shell.conf segger_rtt_shell.conf)\n</code></pre> Now you can compile and flash this application.</p>"},{"location":"Connectivity/CN.6-Segger_RTT/#40-testing","title":"4.0 Testing","text":"<p>To connect to the Segger RTT target, open up a terminal and use the following command <pre><code>JLinkRTTLogger -Device NRF52840_XXAA -RTTChannel 1 -if SWD -Speed 4000 ~/rtt.log\n</code></pre> You should see something like.... <pre><code>------------------------------------------------------------\nConnected to:\n  J-Link EDU Mini V1 compiled Dec  7 2021 08:38:51\n  S/N: 801026632\n\nSearching for RTT Control Block...OK.\n3 up-channels found:\n0: Terminal\n1: \n2: \nSelected RTT Channel description: \n  Index: 1\n  Name:  \n  Size:  0 bytes.\n\nOutput file: /home/twilfred/rtt.log\n\nGetting RTT data from target. Press any key to quit.\n------------------------------------------------------------ \n</code></pre></p> <p>at this point, open up another terminal and <pre><code>nc localhost 19021\n</code></pre> If you setup a console, you should see: <pre><code>SEGGER J-Link V7.58c - Real time terminal output\nJ-Link EDU Mini V1 compiled Dec  7 2021 08:38:51 V1.0, SN=801026632\nProcess: JLinkRTTLoggerExe\n*** Booting Zephyr OS build zephyr-v2.7.0  ***\n</code></pre> and any <code>printk()</code> used after the bootbanner.</p> <p>If you had setup a shell, you should see the shell prompt, where you can now enter commands and/or see logging outputs.</p>"},{"location":"Connectivity/CN.6-Segger_RTT/#50-troubleshooting","title":"5.0 Troubleshooting","text":"<ol> <li> <p>Make sure that your VM has access to the JLink (USB Passthrough), Test with: <code>lsusb</code> <pre><code>$ lsusb\n$ Bus 001 Device 003: ID 1366:0101 SEGGER J-Link PLUS\n</code></pre></p> </li> <li> <p>If this fails: <pre><code>JLinkRTTLogger -Device NRF52840_XXAA -RTTChannel 1 -if SWD -Speed 4000 ~/rtt.log\n</code></pre> Try setting the <code>-RTTChannel 0</code> <pre><code>JLinkRTTLogger -Device NRF52840_XXAA -RTTChannel 0 -if SWD -Speed 4000 ~/rtt.log\n</code></pre></p> </li> <li>If a shell prompt doesn't come up at first, in the <code>nc</code> window. Try pressing enter a few times.</li> </ol>"},{"location":"Connectivity/CN.6-Segger_RTT/#60-sample-applications","title":"6.0 Sample Applications","text":"<p>Sample applications (shell/console) have been provided, these applications include all the steps mentioned above. You can test your devices with using these apps.</p> <p>Shell sample is located in REPO_TOP/tute_solutions/segger_rtt_shell/</p> <p>Console sample is located in:</p> <ul> <li>REPO_TOP/tute_solutions/segger_rtt_console/</li> </ul>"},{"location":"Connectivity/about/","title":"Connectivity Documentation","text":""},{"location":"Connectivity/about/#summary","title":"Summary","text":"<p>The following set of tutorial aim to expose aspects of Zephyr RTOS and handle connectivity. Such as basic GPIO to more advance features like using a console, shell and a logging system.</p>"},{"location":"Connectivity/about/#topic-brief","title":"Topic Brief","text":"<ul> <li> <p>CN.1 - GPIO</p> <ul> <li>Exposing GPIO pins and toggling pins</li> <li>Using devicetree/macros to interface hardware to application(s)</li> </ul> </li> <li> <p>CN.3 - Serial Console</p> <ul> <li>Setting up a console through USB</li> <li>Using printk() and printing to console</li> <li>Specify hardware usage using device tree overlays</li> </ul> </li> <li> <p>CN.4 - Shell</p> <ul> <li>Setting up the Zephyr Shell through USB</li> <li>Use of kernel config files</li> <li>Specify hardware usage using device tree overlays</li> </ul> </li> <li> <p>CN.4 - Shell Commands</p> <ul> <li>Building on CN.4 to add shell commands</li> <li>Commands that can execute a particular subroutine</li> <li>Exposing the Zephyr Shell Command API</li> </ul> </li> <li> <p>CN.5 - Logging</p> <ul> <li>Expose Zephyr Logging sub-system</li> <li>Setup Shell as Logging backend</li> <li>Setup log modules and log filtering</li> </ul> </li> <li> <p>CN.6 - Using SEGGER RTT</p> <ul> <li>Using a Shell through RTT</li> <li>Using a Console through RTT</li> </ul> </li> </ul>"},{"location":"OS/OS.1-Getting_Started/","title":"CSSE4011: Tute 1 - Getting Started with Zephyr RTOS","text":""},{"location":"OS/OS.1-Getting_Started/#10-zephyr-rtos-overview","title":"1.0 Zephyr RTOS: Overview","text":"<p>Zephyr Real-Time Operating System (RTOS) managed by the Linux foundation, is designed for connected and resource constrained embedded devices. Unlike many other real-time operating systems (like free-RTOS), Zephyr is more than just a kernel, it is a software eco-system. Zephyr integrates a broad range of functionality such as:</p> <ol> <li>Bluetooth</li> <li>LoRaWan</li> <li>USB / Serial Console / Shell(CLI)</li> <li>SPI/I2C/UART</li> <li>Flash Drivers</li> <li>Filesystems</li> </ol> <p>and more... Depending on what particular feature your application might require, Zephyr allows you to build a program using only the necessary functionality (i.e BLE), this can optimize the overall footprint of binary. This is done using config file(s) that we will cover in the coming tutorials. </p>"},{"location":"OS/OS.1-Getting_Started/#11-zephyr-kernel-overview","title":"1.1 Zephyr Kernel Overview","text":"<p>The Zephyr kernel is similar to that of free-RTOS at a high level, in that it is primarily concerned with task-scheduling, inter-task communication and synchronization. </p> <ol> <li>Zephyr offers a pre-emptive scheduler, that is, the code context can change at anytime. </li> <li>Thread based, where 'threads' mean the same thing as a 'task' in free-RTOS. </li> <li>It is 'Soft' real-time provided by system ticks</li> </ol>"},{"location":"OS/OS.1-Getting_Started/#12-zephyr-west-meta-tool","title":"1.2 Zephyr West Meta-Tool","text":"<p>Zephyr includes a command line tool named west. This tool provides a multiple repository management system, and Zephyr uses west to provide conveniences for building, flashing, debugging and cleaning applications. For example, to build a program you could use,  <pre><code>west build\n</code></pre> This will look at predefined build configuration settings and build an application as specified. The west meta-tool can be used to perform many other functions, see here for a detailed breakdown of it's features. In this course, you will be using west to build, flash and maintain your workspaces. </p>"},{"location":"OS/OS.1-Getting_Started/#13-zephyr-documentation","title":"1.3 Zephyr Documentation","text":"<p>The Zephyr documentation is well written and contains all the intricate details about Zephyr and it's features. Throughout this course and application development, you will need to refer back to these documentation to understand;</p> <ol> <li>The Build and Configuration Systems </li> <li>Device Tree (A way of describing hardware config to the OS) </li> <li>Application Development (App config options/Kernel config)</li> <li>API Usage </li> <li>Using an Interactive Kconfig interfaces (Optional) </li> </ol> <p>Take some time to read through these documents to get an idea of how Zephyr is implemented. This will be useful later when you are required to implement advanced features using Zephyr. </p>"},{"location":"OS/OS.1-Getting_Started/#20-installing-zephyr-rtos","title":"2.0 Installing Zephyr RTOS","text":"<p>The following guide is made in reference to the Zephyr \"Getting Started Guide\" documentation, and is intended to be used on a Debian based linux distribution with the \"apt\" (package manager installed). </p> <p>First update the system and any installed packages on your VM <pre><code>sudo apt update sudo apt full-upgrade\n</code></pre> Reboot (If this was a fresh OS install, typically kernel is upgraded) <pre><code>sudo reboot\n</code></pre> [Skip kitware for Debian: This is for Ubuntu] Update sources list by adding the Kitware APT repo (contains cmake etc...) <pre><code>cd ~  wget https://apt.kitware.com/kitware-archive.sh\nsudo bash kitware-archive.sh\nsudo rm bash kitware-archive.sh                                   - Remove script\n</code></pre></p> <p>Install cmake, python3 and dtc (device tree compiler) <pre><code>sudo apt install --no-install-recommends git cmake ninja-build gperf \\\nccache dfu-util device-tree-compiler wget \\\npython3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\\nmake gcc gcc-multilib g++-multilib libsdl2-dev\n</code></pre> [Installing CMAKE for Debian] <pre><code>sudo apt remove cmake                   - Remove out of date default package\npip3 install cmake --upgrade            - Install upto date CMAKE\n</code></pre> Log out and back in for pip3 app path to be exported into your environment. </p> <p>Verify dependencies are installed before continuing <pre><code>cmake --version\npython3 --version\ndtc --version\n</code></pre></p>"},{"location":"OS/OS.1-Getting_Started/#30-get-zephyr-and-install-python-dependencies","title":"3.0 Get Zephyr and Install Python dependencies","text":"<p>Install West (Zephyr Meta-tool) <pre><code>pip3 install --user -U west\n\necho 'export PATH=~/.local/bin:\"$PATH\"' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> Setup Zephyr Folder <pre><code>cd /home/user\nmkdir csse4011/\ncd csse4011/\n\nwest init zephyrproject/               - Latest version of Zephyr (the development tree)\n</code></pre> Get Zephyr Source Code (Gets ALL of the source) <pre><code>cd zephyrproject\nwest update                                 - Might take awhile </code></pre> Export a Zephyr CMake package. This allows CMake to automatically load boilerplate code required for building Zephyr applications. <pre><code>west zephyr-export\n</code></pre> Zephyr\u2019s scripts/requirements.txt file declares additional Python dependencies. Install them with pip3. <pre><code>pip3 install --user -r ~/csse4011/zephyrproject/zephyr/scripts/requirements.txt\n</code></pre></p>"},{"location":"OS/OS.1-Getting_Started/#40-installing-the-toolchains","title":"4.0 Installing the toolchains","text":"<p>This tutorial will focus on installing the Zephyr SDK. You may also use 3rd party toolchains, however, for this course, the SDK will be sufficient. Note that Zephyr SDK is not available of Windows or MacOs. You will need to install a 3rd party toolchain, see here.</p> <p>Download the Zephyr SDK installer <pre><code>cd ~\n\nwget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.13.2/zephyr-sdk-0.13.2-linux-x86_64-setup.run\n</code></pre> Install the SDK to /opt/ , see here for other potential installation locations <pre><code>chmod +x zephyr-sdk-0.13.2-linux-x86_64-setup.run\n\nsudo ./zephyr-sdk-0.13.2-linux-x86_64-setup.run -- -d /opt/zephyr-sdk-0.13.2\n</code></pre> Remove SDK Installer (Optional) <pre><code>cd ~\nrm zephyr-sdk-0.13.2-linux-x86_64-setup.run\n</code></pre> Set udev rules, which allow you to flash most Zephyr boards as a regular user <pre><code>sudo cp /opt/zephyr-sdk-0.13.2/sysroots/x86_64-pokysdk-linux/usr/share/openocd/contrib/60-openocd.rules /etc/udev/rules.d\n\nsudo udevadm control --reload\n</code></pre></p>"},{"location":"OS/OS.1-Getting_Started/#50-build-a-sample-program-blinky-for-the-a-board","title":"5.0 Build a Sample Program (Blinky) for the a Board","text":"<p>Refer to tutorial that covers the board, you are using.</p>"},{"location":"OS/OS.1-Getting_Started/#60-setting-zephyr-base","title":"6.0 Setting Zephyr Base","text":"<p>Setting <code>$ZEPHYR_BASE</code> allows you to invoke west from outside the source directory to build your applications. So we will add this environment to be set at login by <code>bashrc</code>. If you are using a different shell <code>fish</code> or <code>zsh</code>, make sure you set this within those config files. </p> <p>If you installed Zephyr elsewhere, adjust the following accordingly.</p> <pre><code>echo \"# Add Zephyr Base Location to Path\nexport ZEPHYR_BASE=~/csse4011/zephyrproject/zephyr\" &gt;&gt; ~/.bashrc source ~/.bashrc\n</code></pre>"},{"location":"OS/OS.1.5-Zephyr_Version_Changes/","title":"CSSE4011: Tute 1.5 - Zephyr Version Changes","text":""},{"location":"OS/OS.1.5-Zephyr_Version_Changes/#10-motivation","title":"1.0 Motivation","text":"<p>This guide will cover how you can go about quickly changing the version of Zephyr. Why might you want to do this?</p> <ul> <li>Newly implemented features you  might want to try.</li> <li>Bug fixes</li> <li>Compatibility Issues</li> <li>Worked on version X, but not on version Y.</li> </ul>"},{"location":"OS/OS.1.5-Zephyr_Version_Changes/#20-upgradingdowngrading","title":"2.0 Upgrading/Downgrading","text":"<p>Start by navigating to Zephyr source location.</p> <p><pre><code>$ cd zephyrproject/zephyr/\n</code></pre> fetch any updates/changes <pre><code>$ git fetch --all\n$ git checkout main\n\n#Bring across all changes\n$ git pull\n</code></pre> To see what the latest releases <pre><code>$ git tag -l | tail\n\n...\nzephyr-v2.5.0\nzephyr-v2.6.0\nzephyr-v2.7.0\nzephyr-v2.7.1\nzephyr-v3.0.0\n</code></pre> checkout the desired release tag/version <pre><code>$ git checkout zephyr-v3.0.0\n</code></pre> Update <code>west</code> to match release requirements <pre><code>west update\n</code></pre></p>"},{"location":"OS/OS.1.5-Zephyr_Version_Changes/#30-build-an-app","title":"3.0 Build an app","text":"<p>Any app you build now (assuming this is where <code>ZEPHYR_BASE</code> is pointing to) will build now on the version you have changed to. If you have build errors, make sure to remove the <code>build/</code> directory for the application.</p> <pre><code>$ west build -p -b particle_argon samples/basic/blinky\n.\n.\n.\n-- west build: building application\n[1/157] Preparing syscall dependency handling\n\n[2/157] Generating include/generated/version.h\n-- Zephyr version: 3.0.0 (/home/twilfred/Embedded_Dev/zephyrproject/zephyr), build: zephyr-v3.0.0\n[147/157] Linking C executable zephyr/zephyr_pre0.elf\n\n[151/157] Linking C executable zephyr/zephyr_pre1.elf\n\n[157/157] Linking C executable zephyr/zephyr.elf\nMemory region         Used Size  Region Size  %age Used\n           FLASH:       19128 B         1 MB      1.82%\n            SRAM:        4168 B       256 KB      1.59%\n        IDT_LIST:          0 GB         2 KB      0.00%\n</code></pre>"},{"location":"OS/OS.2-First_Program/","title":"CSSE4011: Tute 2 - First Program","text":""},{"location":"OS/OS.2-First_Program/#10-motivation","title":"1.0 Motivation","text":"<p>The following tutorial will focus on developing your own very first Zephyr application. This involves, setting up an appropriate directory structure and necessary configuration files.</p>"},{"location":"OS/OS.2-First_Program/#11-hardware-required","title":"1.1 Hardware Required","text":"<ul> <li> <p>Segger JLink EDU Mini</p> </li> <li> <p>Particle Argon</p> </li> <li> <p>2xMicro USB Cables</p> </li> </ul> <p>Connection guide: 1. Connect the Particle Argon using the micro-usb cable to your computer 2. Connect JLink ribbon cable to the JTAG header on the Particle Argon, and the opposing end to the J-Link EDU-mini. The lip of the header should be facing away from the edu mini. 3. Connect the JLink edu mini to your computer, and make sure that USB passthrough for this device is enabled in your virtual machine settings. </p>"},{"location":"OS/OS.2-First_Program/#20-directory-overview","title":"2.0 Directory Overview","text":"<p>A typical Zephyr application is organized in the following format.</p> <pre><code>&lt;home&gt;/apps\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 prj.conf\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.c\n</code></pre> <p>In this course, you will be required to modify and re-use code to implement new features/applications. To allow for this, code that is not specific to an application is placed in a 'myoslib' directory. Where code within 'myoslib' could be drivers for a particular module, for example, an ultrasonic sensor.  The structure below is an example representation.</p> <pre><code>.\n\u251c\u2500\u2500 csse4011_repo/apps/\n\u2502   \u251c\u2500\u2500 prac1/\n\u2502   \u2502   \u251c\u2500\u2500 CMakeLists.txt\n\u2502   \u2502   \u251c\u2500\u2500 prj.conf\n\u2502   \u2502   \u2514\u2500\u2500 src/\n\u2502   \u2502       \u2514\u2500\u2500 main.c \n\u2502   \u2514\u2500\u2500 prac2/\n\u2502       \u251c\u2500\u2500 CMakeLists.txt\n\u2502       \u251c\u2500\u2500 prj.conf\n\u2502       \u2514\u2500\u2500 src/\n\u2502           \u2514\u2500\u2500 main.c\n|\n\u2514\u2500\u2500 csse4011_repo/myoslib/\n    \u251c\u2500\u2500 hal/\n    \u2502   \u251c\u2500\u2500 status_leds/\n    \u2502   \u2502   \u251c\u2500\u2500 hal_status_leds.c \n    \u2502   \u2502   \u2514\u2500\u2500 hal_status_leds.h \n    \u2502   \u2514\u2500\u2500 ultrasonic/\n    \u2502       \u251c\u2500\u2500 hal_ultrasonic.c\n    \u2502       \u2514\u2500\u2500 hal_ultrasonic.h\n    \u2514\u2500\u2500 cli/\n        \u251c\u2500\u2500 cli_kernel_time_cmd.c\n        \u2514\u2500\u2500 cli_status_leds_cmd.c\n</code></pre>"},{"location":"OS/OS.2-First_Program/#30-making-a-zephyr-application","title":"3.0 Making A Zephyr Application","text":"<p>Within the 'csse4011_repo', make the following modifications to setup a sample directory <pre><code>cd ~/csse4011/csse4011_repo/\nmkdir -p apps/sample\n</code></pre> For the purposes of this tutorial, we will use the existing blinky sample provided in the Zephyr source code.</p> <p>Start by navigating to the Zephyr source we attained in Tute 1.</p> <p><pre><code>cd ~/csse4011/zephyrproject/zephyr/samples/basic/blinky\n</code></pre> Copy blinky files into our sample application directory, then navigate to sample directory. <pre><code>cp -R * ~/csse4011/csse4011_repo/apps/sample/\ncd ~/csse4011/csse4011_repo/apps/sample/\n</code></pre> Verify that the following exist within your sample dir <pre><code>.\n\u2514\u2500\u2500 csse4011/csse4011_repo/apps/\n    \u2514\u2500\u2500 sample/\n        \u251c\u2500\u2500 CMakeLists.txt\n        \u251c\u2500\u2500 prj.conf\n        \u251c\u2500\u2500 README.rst\n        \u251c\u2500\u2500 sample.yaml\n        \u2514\u2500\u2500 src/\n            \u2514\u2500\u2500 main.c\n</code></pre> Add ZEPHYR_BASE to path (Lets you build from outside the Zephyr Source Dir). Append the following line to the end of 'bashrc' (If you haven't already from OS.1). For text editing you can use <code>nano</code> instead of <code>vim</code> as it is usually installed by default. </p> <p>To install vim. <pre><code>sudo apt install vim\n</code></pre></p> <p><pre><code>vim ~/.bashrc                               or use any text editor\n\n#Add Zephyr Base to PATH\nexport ZEPHYR_BASE=~/csse4011/zephyrproject/zephyr   \n</code></pre> save and exit.</p> <p>Read and execute bashrc (Loads ZEPHYR_BASE for current shell instance) <pre><code>source ~/.bashrc\necho $ZEPHYR_BASE\n</code></pre> Should now display the path to zephyr base. </p> <p>Build the sample application within our directory <pre><code>cd ~/csse4011/csse4011_repo/apps/sample/\nwest build -p auto -b particle_argon\n</code></pre> Flash and Verify that Blinky works.  <pre><code>west flash -r jlink\n</code></pre></p> <p>The option '-r' lets you specify a runner, in this case we are using JLink to flash the Particle Argon. Make sure that the cables are connected properly.</p> <p>If flashing fails, refer to the end of <code>OS.1-Getting Started</code> and follow instructions for installing runners / additional runners. </p>"},{"location":"OS/OS.2-First_Program/#40-sample","title":"4.0 Sample","text":"<p>A sample of this is located within</p> <ul> <li>tute_solutions/blinky_tute/</li> </ul>"},{"location":"OS/OS.2.1-Building_Tips/","title":"CSSE4011: Tute 2.2 - Application Building Tips","text":""},{"location":"OS/OS.2.1-Building_Tips/#10-motivation","title":"1.0 Motivation","text":"<p>This tutorial will focus on modifications to the CMakeLists file to streamline the application development process. </p>"},{"location":"OS/OS.2.1-Building_Tips/#20-setting-build-options","title":"2.0 Setting Build Options","text":"<p>Note that these should be added to the top of the CMakeLists file. Additionally, there are other ways to include config files and devicetree overlays. Refer to a application development and device tree guides for more.</p>"},{"location":"OS/OS.2.1-Building_Tips/#21-boards","title":"2.1 Boards","text":"<p>A board to develop can be specified within the top level CMakeLists file as below, the particular name for the board can be found under Zephyr Supported Boards -&gt; boardname or here.</p> <pre><code>set(BOARD board_name)\n\nset(BOARD particle_argon)\n</code></pre> <p>With this set, west build can now omit the '-b board_name' option. By just using </p> <pre><code>west build \n</code></pre> <p>an application can be created for the particle_argon.</p>"},{"location":"OS/OS.2.1-Building_Tips/#22-runners","title":"2.2 Runners","text":"<p>The flash runner for the board can be set using the below, within the CMakeLists file.</p> <pre><code>set(BOARD_FLASH_RUNNER runner)\n\nset(BOARD_FLASH_RUNNER jlink)\n</code></pre> <p>This allows for west flash to be ran with about specifying the '-r runner' when invoked. </p> <pre><code>west flash\n</code></pre>"},{"location":"OS/OS.2.1-Building_Tips/#23-config-files","title":"2.3 Config Files","text":"<p>Config option files (ending with .conf), can be added to the CMakeLists file using,</p> <pre><code>set(CONF_FILE files.conf)\n\nset(CONF_FILE general_config.conf usb_config.conf uart_shell_config.conf)\n</code></pre>"},{"location":"OS/OS.2.1-Building_Tips/#24-devicetree-overlays","title":"2.4 Devicetree overlays","text":"<p>Devicetree overlay files can be added to the build system using,</p> <pre><code>set(DTC_OVERLAY_FILE overlay.dtsi)\n\nset(DTC_OVERLAY_FILE dts/spi3.dtsi)\n</code></pre>"},{"location":"OS/OS.2.2-Implementing_Libraries/","title":"CSSE4011: Tute 2.2 - Implementing a Simple Library","text":""},{"location":"OS/OS.2.2-Implementing_Libraries/#10-motivation","title":"1.0 Motivation","text":"<p>The following tutorial looks at implementing a simple library and adding library files to the build system. </p>"},{"location":"OS/OS.2.2-Implementing_Libraries/#20-implementing-a-basic-library","title":"2.0 Implementing A Basic Library","text":""},{"location":"OS/OS.2.2-Implementing_Libraries/#21-including-library-files","title":"2.1 Including library files","text":"<p>We will build on the blinky sample that was created in OS.2-First_Program. We will start by creating a library file to implement functions that will:</p> <ul> <li>Initialize GPIO for led</li> <li>Provide a wrapper functions for turning led on and off.</li> </ul> <p>The following directory structure will be implemented for this basic library application. Where, blinky_tute_ext is a copy of the application made in OS.2-First_Program. </p> <pre><code>.\n\u251c\u2500\u2500 blinky_tute\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CMakeLists.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 prj.conf\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.c\n\u251c\u2500\u2500 blinky_tute_ext\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CMakeLists.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 prj.conf\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.c\n\u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 led_driver\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 led_driver.c\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 led_driver.h\n</code></pre>"},{"location":"OS/OS.2.2-Implementing_Libraries/#22-library-files","title":"2.2 Library Files","text":"<p>In this example, the library files are in lib/led_driver/, where:</p> <p>led_driver.c - provides simple led wrapper functions to demonstrate a library implementation.</p> <p>led_driver.h - provides the respective header file to be included by any shared targets. </p>"},{"location":"OS/OS.2.2-Implementing_Libraries/#221-creating-a-library-source-file-led_driverc","title":"2.2.1 Creating a library source file (led_driver.c)","text":"<p>First include necessary Zephyr headers files required by the application, in this case, for an led to toggle, we use. </p> <p><pre><code>#include &lt;zephyr.h&gt;\n#include &lt;device.h&gt;\n#include &lt;devicetree.h&gt;\n#include &lt;drivers/gpio.h&gt;\n/* Local Library Include */\n#include \"led_driver.h\"\n</code></pre> This can be followed by any source code required to implement the application/driver logic. </p>"},{"location":"OS/OS.2.2-Implementing_Libraries/#222-creating-a-library-header-file-led_driverh","title":"2.2.2 Creating a library header file (led_driver.h)","text":"<p>The header file can be made as per usual using typical syntax. There are no particular restrictions on the way this is implemented. </p> <pre><code>#ifdef LED_DRIVER_H\n#define LED_DRIVER_H\n/* Device Tree Macros */\n#define LED0_NODE DT_ALIAS(led0)\n/* Function Prototypes..*/\nint led0_init(void);\n#endif\n</code></pre>"},{"location":"OS/OS.2.2-Implementing_Libraries/#23-adding-sources-and-header-files-to-cmakelists","title":"2.3 Adding Sources and Header files to CMakeLists","text":"<p>With this, you can now created a basic library to implement re-usable code. However, to add this to the build system of this intended application. You must add these files to the CMakeLists file of the target application. In this case the following file  blinky_tute_ext/CMakeLists.txt</p> <pre><code>Append the following to the CMakeLists.txt file\n#Add Include Directories\ninclude_directories(\n../lib/led_driver/\n)\n#Add Target Sources\ntarget_sources(app PRIVATE\nsrc/main.c\n../lib/led_driver/led_driver.c\n)\n</code></pre> <p>Note: That relative paths are interpreted as relative to the current source directory. </p> <p>Note: That include_directories(x/y) applies the include directories to all targets, if you want to specify which targets use with includes, use target_include_directories(t x/y), see here</p> <p>CMakeLists documentation states that: The include directories are added to the directory property INCLUDE_DIRECTORIES for the current CMakeLists file. They are also added to the target property INCLUDE_DIRECTORIES for each target in the current CMakeLists file. The target property values are the ones used by the generators.</p> <p>You can also use a seperate CMakeLists files to compile your libraries using a hierarchical cmake build system if desired. Refer to cmake build system documentation for more.</p>"},{"location":"OS/OS.2.2-Implementing_Libraries/#24-using-library-code-in-target-application","title":"2.4 Using Library Code in Target Application","text":"<p>Finally, we can now use the library code within our target application. To do this, include the respective header files. In this case, include the following in src/main.c</p> <pre><code>/* Include file from our library */\n#include \"led_driver.h\"\n</code></pre> <p>Now you can call the library functions as desired. </p>"},{"location":"OS/OS.2.2-Implementing_Libraries/#30-tutorial-question","title":"3.0 Tutorial Question","text":"<p>Using the above, extend the blinky program by implementing simple wrapper functions to:</p> <ul> <li> <p>Init led gpio pin</p> </li> <li> <p>Power on/off led0 pin</p> </li> <li> <p>Deinit led gpio pin</p> </li> </ul> <p>Refer to the Zephyr GPIO API</p>"},{"location":"OS/OS.2.2-Implementing_Libraries/#40-sample-solution","title":"4.0 Sample Solution","text":"<p>A sample solution is uploaded in the docs repository. Find located within,</p> <ul> <li> <p>tute_solutions/blinky_tute_ext/src/</p> </li> <li> <p>tute_solutions/lib/led_driver/</p> </li> </ul> <p>This code can be built with: <pre><code>west build -p -b &lt;board_name&gt;\n</code></pre></p> <p>and flashed with</p> <pre><code>west flash -r 'runner'\n</code></pre> <p>Refer to the board flashing tutorials for additional build/flash guides.</p>"},{"location":"OS/OS.4-Threading/","title":"CSSE4011: Tute 4 - Threading in Zephyr","text":""},{"location":"OS/OS.4-Threading/#10-motivation","title":"1.0 Motivation","text":"<p>In this tutorial, we focus on learning the use of threads in Zephyr RTOS. The use of threads is to implement an application that can 'multi-task'.</p>"},{"location":"OS/OS.4-Threading/#11-summary-of-threads","title":"1.1 Summary of threads","text":"<p>Threads are typically created with an appropriate level of priority based on their task within the application, and also an appropriate stack size. When a thread is interrupted and switched out for another thread (code context changed), this is know as a context switch. Typically, based on thread synchronization implementation/priorities, the kernel will perform a context switch between threads, allowing for other threads to perform their duties. On a micro-controller unit (MCU), this mimics 'multi-tasking' within a program.</p> <p>Example, in an IoT based application, where an application may need to maintain a network, communicate and collect data from hardware sensors, maintain a device power profile. Threads allow an application to maintain multiple 'threads' of execution with different contexts.</p>"},{"location":"OS/OS.4-Threading/#20-threads-in-zephyr","title":"2.0 Threads in Zephyr","text":"<p>In Zephyr [1], a thread is a kernel object that is used for application processing that is too lengthy or too complex to be performed by an interrupt service routine (ISR). Any number of threads can be defined by an application (limited only by available RAM). Each thread is referenced by a thread id that is assigned when the thread is spawned. Additionally, each thread is allocated a specific priority and a stack size at creation (see here for more details).</p>"},{"location":"OS/OS.4-Threading/#21-using-threads-in-zephyr-rtos","title":"2.1 Using threads in Zephyr RTOS","text":"<p>There are two ways in which a threads can be created in Zephyr, compile-time and at run-time. An application that has fixed functionality, can be solely implemented with compile-time threads. When compile-time thread is defined, it starts immediately as the program begins. Note, that there is not inherent diffrence between compile-time and run-time threads, other than the way in which they are created.</p> <p>If an application requires a thread to be created at run-time, a run-time thread can be created, this process is similar to how threads are created in freeRTOS. </p>"},{"location":"OS/OS.4-Threading/#22-thread-creation-in-zephyr-rtos","title":"2.2 Thread Creation in Zephyr RTOS","text":"<p>NOTE: It is strongly recommended that you read the Zephyr thread API, as it shows you the intricate details and correct usage of the API for additional features.</p>"},{"location":"OS/OS.4-Threading/#221-compile-time-threads","title":"2.2.1 Compile-Time Threads","text":"<p>A compile-time thread in Zephyr is created by the following macro. <pre><code>K_THREAD_DEFINE(name, stack_size, entry, p1, p2, p3, prio, options, delay)\n</code></pre></p> <p>The below snippet shows how a compile-time thread can be setup. Refer to Zephyr Thread API for more details.</p> <pre><code>#define MY_STACK_SIZE 500\n#define MY_PRIORITY 5\nvoid my_entry_point(void *, void *, void *);\nK_THREAD_DEFINE(my_tid, MY_STACK_SIZE,\nmy_entry_point, NULL, NULL, NULL,\nMY_PRIORITY, 0, 0);\n/* A thread, that does some work */\nvoid\nmy_entry_point(void *a, void *b, void *c)\n{\nwhile(1) {\n/*\n         * do some work\n         */\nk_msleep(1000);\n}\n}\n</code></pre>"},{"location":"OS/OS.4-Threading/#222-run-time-threads","title":"2.2.2 Run-Time Threads","text":"<p>Run-time threads in Zephyr can be created as seen below. This code performs the same fundamental actions as compile-time thread. However, it is created at run-time. </p> <pre><code>#define MY_STACK_SIZE 500\n#define MY_PRIORITY 5\nvoid my_entry_point(void *, void *, void *);\nK_THREAD_STACK_DEFINE(my_stack_area, MY_STACK_SIZE);\nstruct k_thread my_thread_data;\n/* Application entry point */\nint\nmain(void) {\n/* Spawn new thread at run-time */\nk_tid_t my_tid = k_thread_create(&amp;my_thread_data, my_stack_area,\nK_THREAD_STACK_SIZEOF(my_stack_area),\nmy_entry_point,\nNULL, NULL, NULL,\nMY_PRIORITY, 0, K_NO_WAIT);\nreturn 0;\n}\n/* A thread, that does some work */\nvoid\nmy_entry_point(void *a, void *b, void *c)\n{\nwhile(1) {\n/*\n         * do some work\n         */\nk_msleep(1000);\n}\n}\n</code></pre>"},{"location":"OS/OS.4-Threading/#223-thread-priorities","title":"2.2.3 Thread Priorities","text":"<p>In Zephyr RTOS, a thread\u2019s priority is an integer value, and can be either negative or non-negative. Numerically lower priorities takes precedence over numerically higher values. For example, the scheduler gives thread A of priority 4 higher priority over thread B of priority 7; likewise thread C of priority -2 has higher priority than both thread A and thread B see here.</p> <p>Priorities for threads should be chosen carefully based on the application. You may notice issues with thread starvation (not getting enough time to run), if priorities are chosen inappropriately. A threads priority can also be changed after it has been created. </p>"},{"location":"OS/OS.4-Threading/#224-thread-scheduling","title":"2.2.4 Thread Scheduling","text":"<p>The kernel\u2019s priority-based scheduler allows an application\u2019s thread to share the CPU. There are two different 'types' of threads in Zephyr with respect to the scheduler. These are 'Pre-emptive' and 'Cooperative' threads. In summary, once a cooperative thread becomes the current thread, it remains the current thread until it performs an action that makes it unready. Whereas, a preemptive thread becomes the current thread, it remains the current thread until a higher priority thread becomes ready, or until the thread performs an action that makes it unready see here.</p> <ul> <li> <p>A cooperative thread has a negative priority value. </p> </li> <li> <p>A preemptible thread has a non-negative priority value. </p> </li> </ul> <p>In application as per, </p> <ul> <li> <p>Use cooperative threads for device drivers and other performance-critical work.</p> </li> <li> <p>Use cooperative threads to implement mutually exclusion without the need for a kernel object, such as a mutex.</p> </li> <li> <p>Use preemptive threads to give priority to time-sensitive processing over less time-sensitive processing.</p> </li> </ul>"},{"location":"OS/OS.4-Threading/#30-tutorial-question","title":"3.0 Tutorial Question:","text":"<p>Copy the zephyr/sample/blinky program to a working application directory, then, implement two threads, where one thread will turn on the led, and the other thread will turn off the led. Use any of the boards to test your code.</p> <p>Question: What is wrong with an implementation like this? Why is this not ideal, what type of issues might you run into?</p>"},{"location":"OS/OS.4-Threading/#31-sample-solution","title":"3.1 Sample Solution","text":"<p>A sample solution is uploaded in the docs repository. Find located within,</p> <ul> <li>REPO_TOP/tute_soltions/threading_sample</li> </ul> <p>This code can be built with:</p> <pre><code>west build -p -b &lt;board_name&gt;\n</code></pre> <p>and flashed with <pre><code>west flash -r 'runner'\n</code></pre></p> <p>Refer to the board flashing tutorials for additional build/flash guides.</p>"},{"location":"OS/OS.5.1-Thread_Sync/","title":"CSSE4011: Tute 5.1 - Thread Synchronization","text":""},{"location":"OS/OS.5.1-Thread_Sync/#10-motivation","title":"1.0 Motivation","text":"<p>In the previous tutorial, basic thread creation and usage was covered. In this tutorial, we aim to cover thread synchronization.</p>"},{"location":"OS/OS.5.1-Thread_Sync/#11-thread-synchronization-summary","title":"1.1 Thread Synchronization Summary","text":"<p>Thead synchronization is typically used for sharing of resources without interference (mutual exclusion) and for coordinating the thread functionality and interactions within the operating system. </p> <p>For example, think of a resource where multiple threads write to a shared resource. It is important to ensure that only one writer is currently writing to the resource, to avoid interference and data corruption. In such a case, synchronization must be used between the writer threads to ensure intended functionality. Additionally, the application could use coordination between reader and writer threads, so that readers only read when data is ready. </p> <p>In an embedded environment, an application might want to enforce that only one thread is accessing hardware (senors etc..) at a time, or to indicate that a particular hardware resource is ready to use. In such a case, synchronization must be used. </p>"},{"location":"OS/OS.5.1-Thread_Sync/#20-thread-synchronization-and-communication-in-zephyr","title":"2.0 Thread Synchronization and Communication in Zephyr","text":""},{"location":"OS/OS.5.1-Thread_Sync/#21-thread-synchronization-in-zephyr","title":"2.1 Thread Synchronization in Zephyr","text":"<p>Zephyr offers multiple synchronization primitives, such as:</p> <ol> <li> <p>Semaphores</p> </li> <li> <p>Mutexs </p> </li> <li> <p>Condition Variables </p> </li> </ol> <p>Refer to the API guides (links section) for detailed information on implementing each of the above. In this tute, we will explore using semaphores to synchronize the blinky thread created in OS.4-Threading. </p>"},{"location":"OS/OS.5.1-Thread_Sync/#22-semaphore-implementation","title":"2.2 Semaphore Implementation","text":"<p>Within Zephyr, a semaphore can be defined by the use of the following macro</p> <pre><code>K_SEM_DEFINE(sem_name, 0, 1);\n</code></pre> <p>or, using the function  k_sem_init()</p> <pre><code>struct k_sem sem_name;\nvoid\nmain(void)\n{\nk_sem_init(&amp;sem_name, 0, 1);\n}\n</code></pre> <p>The typical application of a semaphore can be as seen below:</p> <p><pre><code>void\ninterrupt_handler(void *arg)\n{\n/* Interrupt indicative of some data ready */\nk_sem_give(&amp;data_ready_sem);\n}\nvoid\nconsumer_thread(void)\n{\nwhile(1)\n{\nif (k_sem_take(&amp;data_ready_sem, K_MSEC(850) != 0)) {\n/* \n             * Data not received within expected timeout of 850ms, \n             * fallback subroutine...\n             */\ncontinue;\n}\n/* Semaphore was attained within time out */\n/* Read the data, and do some work... */\nk_msleep(500);\n}\n}\n</code></pre> The example above, shows a scenario where a semaphore is used to signal by an interrupt handler that some data is ready. Similarly, semaphores can be used between multiple threads for coordination and signaling. </p> <p>Refer to here, for additional implementation information. </p>"},{"location":"OS/OS.5.1-Thread_Sync/#23-mutex-in-zephyr","title":"2.3 Mutex in Zephyr","text":"<p>A mutex in Zephyr RTOS is a kernel object that implements the traditional functionality of a mutex. A mutex can allow multiple threads to safely access and share hardware or software resources as per. Where a semaphore may allow finite access (i.e counting semaphore) to a resource, mutexs only allow a thread to access one resource at a time (a locking mechanism). </p> <p>The mutex implementation api within Zephyr is functionally similar to that of the semaphore api outlined in section 2.2. See here for Zephyr mutex api guide.</p>"},{"location":"OS/OS.5.1-Thread_Sync/#24-condition-variables-in-zephyr","title":"2.4 Condition Variables in Zephyr","text":"<p>Zephyr allows for 'Condition Variables' to be used as a synchronization primitive, where, threads can wait on until a particular condition has occurred. Waiting threads will be in a queue when a particular state of execution is not desired (by waiting on the condition).</p> <p>Zephyr Condition Variable API shows the following example to be  a typical conditional variable implementation with two threads. In the main thread, </p> <p><pre><code>K_MUTEX_DEFINE(mutex);\nK_CONDVAR_DEFINE(condvar)\nvoid main(void)\n{\nk_mutex_lock(&amp;mutex, K_FOREVER);\n/* block this thread until another thread signals cond. While\n     * blocked, the mutex is released, then re-acquired before this\n     * thread is woken up and the call returns.\n     */\nk_condvar_wait(&amp;condvar, &amp;mutex, K_FOREVER);\n...\nk_mutex_unlock(&amp;mutex);\n}\n</code></pre> and in the worker thread,</p> <pre><code>void worker_thread(void)\n{\nk_mutex_lock(&amp;mutex, K_FOREVER);\n/*\n     * Do some work and fulfill the condition\n     */\n...\n...\nk_condvar_signal(&amp;condvar);\nk_mutex_unlock(&amp;mutex);\n}\n</code></pre>"},{"location":"OS/OS.5.1-Thread_Sync/#241-condition-variable-typical-use","title":"2.4.1 Condition Variable Typical Use","text":"<p>Condition variables should be used with a mutex to signal changing conditions/states from one thread to another. Condition variables are not events in that they are not the condition itself.</p> <p>Refer to the implementation API for more details.</p>"},{"location":"OS/OS.5.1-Thread_Sync/#30-tutorial-question","title":"3.0 Tutorial Question","text":"<p>1. Use two semaphores to enforce synchronization between the two blinky threads created in tute OS.4-Threading.</p> <p>The implementation should only use delays to indicate that the led visibly blinks. </p>"},{"location":"OS/OS.5.1-Thread_Sync/#31-sample-solution","title":"3.1 Sample Solution","text":"<p>A sample solution is uploaded in the docs repository. Find located within,</p> <ul> <li>tute_solutions/thread_sync_sample</li> </ul> <p>This code can be built with:</p> <pre><code>west build -p -b &lt;board_name&gt;\n</code></pre> <p>and flashed with</p> <pre><code>west flash -r 'runner'\n</code></pre> <p>Refer to the board flashing tutorials for additional build/flash guides.</p>"},{"location":"OS/OS.5.2-Thread_Communication/","title":"CSSE4011: Tute 5.2 - Thread Communication","text":""},{"location":"OS/OS.5.2-Thread_Communication/#10-motivation","title":"1.0 Motivation","text":"<p>The following tutorial aims to introduce inter-thread communication (ITC) and useful communication primitives within Zephyr RTOS. </p>"},{"location":"OS/OS.5.2-Thread_Communication/#11-inter-thread-communication-itc","title":"1.1 Inter-Thread Communication (ITC)","text":"<p>Similar to inter-process-communications (IPC) in typical operating systems, ITC allows one thead to share data between another thread(s). Where mutexs and semaphores are typically used for mutual exclusion and signalling, data passing/ITC allows for threads to communicate beyond primitive signaling. </p>"},{"location":"OS/OS.5.2-Thread_Communication/#12-prerequisites","title":"1.2. Prerequisites","text":"<p>Ensure that you have completed/understand the following tutorials. </p> <ul> <li>OS.1, OS.2, OS.2.1, BRD.1 and CN.3-Serial_Console or CN.5-Shell (for printk() usage)</li> </ul>"},{"location":"OS/OS.5.2-Thread_Communication/#20-thread-communication-in-zephyr","title":"2.0 Thread Communication in Zephyr","text":""},{"location":"OS/OS.5.2-Thread_Communication/#21-data-passing-in-zephyr","title":"2.1 Data Passing in Zephyr","text":"<p>Zephyr RTOS offers a few different options for ITC. To name a few,</p> <ul> <li>First in first out buffers (FIFO)</li> <li>Last in first out buffer (LIFO)</li> <li>Stacks</li> <li>Message queues, Mailboxes and Pipes</li> </ul> <p>Some of these are ideal for particular use cases, to determine which ITC protocol might best fit an application, refer to the Data Passing guidelines table. More information on the implementation of each primitive can be found in the api guides (links below the table).</p>"},{"location":"OS/OS.5.2-Thread_Communication/#22-general-message-queues","title":"2.2 General Message Queues","text":"<p>In this tutorial, we will focus on implementing a message queues between threads. As they can be typically be used for a wide range of applications, it is a good starting point for learning ITC in Zephyr. The api guide can be found here.</p> <p>What is a message queue?</p> <ul> <li>\"A message queue is a kernel object that implements a simple message queue, allowing threads and ISRs to asynchronously send and receive fixed-size data items.\"</li> </ul>"},{"location":"OS/OS.5.2-Thread_Communication/#23-implementing-message-queues","title":"2.3 Implementing Message Queues","text":"<p>Start by making a basic Zephyr application, you may use a copy of the sample solution provided in CN.4-Shell (shell_example) and use this as a boilerplate. The provided solution has USB-Shell and USB-Printk enabled. </p> <p>Start by editing the source file. <pre><code>vim src/main.c\n</code></pre> The following macro allows for the definition of a message queue in Zephyr, add this to your source file.  <pre><code>K_MSGQ_DEFINE(my_msgq, sizeof(struct data_packet), 10, 4);\n</code></pre> Where, a message queue named my_msgq is initialized, that queues 10 struct data_packet items, where the structure is aligned to an address that is divisible by 4 (4-byte aligned). </p> <p>To make this work, we must also define a struct data_packet globally (before macro usage). <pre><code>struct data_packet {\nuint16_t preamble;\nchar string[32];\n};\n</code></pre> In our main(), we can add some data to our struct <pre><code>/* MSGQ Packet */\nstruct data_packet packet;\npacket.preamble = 0xAA;\nsnprintk(packet.string, sizeof(packet.string), \"Colonels Recipe.exe\\n\");\n</code></pre> and lets put this packet on our queue, (add this to the while loop in main()) <pre><code>/* Send Messages to consumers */\nif (k_msgq_put(&amp;my_msgq, &amp;packet, K_NO_WAIT) != 0) {\n/* Queue is full, we could purge it, a loop can be\n        * implemented here to keep trying after a purge.\n        */\nk_msgq_purge(&amp;my_msgq);\n}\n</code></pre> Now, we will add another thread (alongside main), so we can test the ITC between two threads using the message queue. Note: Make sure to give this thread sufficient stack size as message queues are passed by copy. </p> <pre><code>/* Define Consumer Thread */\nvoid consumer_thread(void);\n#define STACK_SIZE 1024\n#define THREAD_PRIOR 3\n#define THREAD_DELAY 0\n#define OPTIONS 0\nK_THREAD_DEFINE(consumer_thread_tid, STACK_SIZE, consumer_thread, NULL, NULL, NULL, THREAD_PRIOR, OPTIONS, THREAD_DELAY);\n/*\n * Consumer thread for testing message queue\n */\nvoid\nconsumer_thread(void)\n{\nstruct data_packet data;\nwhile(1) {\nif (k_msgq_get(&amp;my_msgq, &amp;data, K_FOREVER) == 0) {\nif (data.preamble == 0xAA)\nprintk(\"MSG Received: %s\\n\", data.string);\nmemset(&amp;data, 0, sizeof(struct data_packet));\n}\n}\n}\n</code></pre>"},{"location":"OS/OS.5.2-Thread_Communication/#24-testing","title":"2.4 Testing","text":"<p>This application can now be built and flashed using: <pre><code>west  build -p auto -b particle_argon\nwest flash -r jlink\n</code></pre> As per previous guides on Shell and Console implementation, attach a session to screen.  <pre><code>sudo screen /dev/ttyACM0\n</code></pre> <pre><code>[00:00:00.005,340] &lt;inf&gt; usb_cdc_acm: Device suspended\n[00:00:00.165,863] &lt;inf&gt; usb_cdc_acm: Device resumed\n[00:00:00.432,922] &lt;inf&gt; usb_cdc_acm: Device configured\nMSG Received: Colonels Recipe.exe\n\nMSG Received: Colonels Recipe.exe\n\nMSG Received: Colonels Recipe.exe\n\nMSG Received: Colonels Recipe.exe\n\nMSG Received: Colonels Recipe.exe\n\nCSSE4011:~$\n</code></pre></p>"},{"location":"OS/OS.5.2-Thread_Communication/#25-additional-notes","title":"2.5 Additional Notes","text":"<p>This tutorial is a guide for implementing basic message queues in Zephyr RTOS, it is strongly suggested that you refer to the Zephyr API guides here and here for additional information.</p>"},{"location":"OS/OS.5.2-Thread_Communication/#30-sample-solution","title":"3.0 Sample Solution","text":"<p>A sample solution is provided under, </p> <ul> <li>REPO_TOP/tute_soltions/thread_comms_sample/</li> </ul> <p>this solution implements the above functionality into a Zephyr application. Feel free to use it and modify it.</p>"},{"location":"OS/about/","title":"Zephyr RTOS - Guides","text":""},{"location":"OS/about/#summary","title":"Summary","text":"<p>The following set of tutorials are intended to help students get setup with Zephyr RTOS on their newly setup virtual machines (Debian based), and to get a basic application to compile. </p> <p>These tutorials are intended to be attempted in order, particularly the first few.</p>"},{"location":"OS/about/#topic-brief","title":"Topic Brief","text":"<ul> <li>OS.1 - Getting Started <ul> <li>Cloning and setting up Zephyr RTOS (installing toolchains and other required packages), on Debian/Ubuntu.</li> <li>Building and flashing sample blinky app</li> </ul> </li> <li>OS.2 - First Program<ul> <li>Setting up and building a Zephyr application (outside Zephyr source directory)</li> <li>Setting up app working directories</li> </ul> </li> <li>OS.2.1 - Building Tips<ul> <li>Basics of the build system</li> <li>Tips to customize build system</li> <li>Including config files</li> </ul> </li> <li>OS.2.2 - Implementing Libraries<ul> <li>Library directory structures</li> <li>Adding library to app build system</li> </ul> </li> <li>OS.4 - Threading<ul> <li>Introduction to threads</li> <li>Thread implementation in Zephyr RTOS</li> </ul> </li> <li>OS.5.1 - Thread Synchronization<ul> <li>Introduction to thread synchronization</li> <li>Semphore, Mutex and Condition Variables implementation</li> </ul> </li> <li>OS.5.2 - Thread Communication (ITC)<ul> <li>Introduction to inter-thread-communication (ITC)</li> <li>Basic communication primitives</li> <li>Implementation of Zephyr message queues.</li> </ul> </li> </ul>"},{"location":"OS/about/#notes","title":"Notes:","text":"<ul> <li> <p>The following tutorials were created with reference to Zephyr RTOS V2.7.XX. </p> </li> <li> <p>Through these guide, the reference to the environment variable <code>(REPO_TOP)</code> refers to the top level directory of within tutedocs. </p> </li> </ul>"}]}